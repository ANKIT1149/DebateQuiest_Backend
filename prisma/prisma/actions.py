# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE clerk_id = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'clerk_id': 'ggciceaie',
                'username': 'bbehjachib',
                'email': 'cadfabfehe',
                'grade': 'dgiiaaijj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'clerk_id': 'bfaiacjjfc',
                    'username': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'grade': 'cghideieh',
                },
                {
                    # data to create a User record
                    'clerk_id': 'biabhbdai',
                    'username': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'grade': 'hjaecfifb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'cbbbjbfcii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the email field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bdiicjafbj',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bgehebiafc',
            },
            data={
                'create': {
                    'id': 'bgehebiafc',
                    'clerk_id': 'biabhbdai',
                    'username': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'grade': 'hjaecfifb',
                },
                'update': {
                    'clerk_id': 'biabhbdai',
                    'username': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'grade': 'hjaecfifb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'grade': 'bghffegacj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'imageUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeysT'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by clerk_id values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['clerk_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class quizzesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.quizzes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await quizzes.prisma().query_raw(
            'SELECT * FROM quizzes WHERE id = $1',
            1767274722,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.quizzes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await quizzes.prisma().query_first(
            'SELECT * FROM quizzes WHERE title = $1',
            'dcgchcbbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.quizzesCreateInput,
        include: Optional[types.quizzesInclude] = None
    ) -> _PrismaModelT:
        """Create a new quizzes record.

        Parameters
        ----------
        data
            quizzes record data
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The created quizzes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a quizzes record from just the required fields
        quizzes = await quizzes.prisma().create(
            data={
                # data to create a quizzes record
                'title': 'bdedcabahc',
                'quizId': 'ghfhiafcb',
                'grade': 'heejgedji',
                'level': 'bjgjgibgbf',
                'question': 'bbbgbhfjge',
                'options': Json({'igbehcbab': True}),
                'correct_answer': 'bdadaadhag',
                'explanation': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.quizzesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple quizzes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of quizzes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await quizzes.prisma().create_many(
            data=[
                {
                    # data to create a quizzes record
                    'title': 'caaaedabfc',
                    'quizId': 'bigibebcib',
                    'grade': 'bigaiehgcc',
                    'level': 'beeifcbebf',
                    'question': 'bgcigfahea',
                    'options': Json({'bcejgaggif': True}),
                    'correct_answer': 'idfjadbcc',
                    'explanation': 'hgdhbjhhj',
                },
                {
                    # data to create a quizzes record
                    'title': 'ecjjjfbae',
                    'quizId': 'bhhfibbigf',
                    'grade': 'ijdbeffgg',
                    'level': 'jjfeafhfj',
                    'question': 'cbachdgfce',
                    'options': Json({'chbfcacbd': True}),
                    'correct_answer': 'efggddide',
                    'explanation': 'caficfigfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.quizzesWhereUniqueInput,
        include: Optional[types.quizzesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single quizzes record.

        Parameters
        ----------
        where
            quizzes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The deleted quizzes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quizzes = await quizzes.prisma().delete(
            where={
                'id': 1583689592,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.quizzesWhereUniqueInput,
        include: Optional[types.quizzesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique quizzes record.

        Parameters
        ----------
        where
            quizzes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The found quizzes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quizzes = await quizzes.prisma().find_unique(
            where={
                'id': 878442065,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.quizzesWhereUniqueInput,
        include: Optional[types.quizzesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique quizzes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            quizzes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The found quizzes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quizzes = await quizzes.prisma().find_unique_or_raise(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
        include: Optional[types.quizzesInclude] = None,
        order: Optional[Union[types.quizzesOrderByInput, List[types.quizzesOrderByInput]]] = None,
        distinct: Optional[List[types.quizzesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple quizzes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of quizzes records returned
        skip
            Ignore the first N results
        where
            quizzes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quizzes model
        order
            Order the returned quizzes records by any field
        distinct
            Filter quizzes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.quizzes]
            The list of all quizzes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 quizzes records
        quizzes = await quizzes.prisma().find_many(take=10)

        # find the first 5 quizzes records ordered by the quizId field
        quizzes = await quizzes.prisma().find_many(
            take=5,
            order={
                'quizId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
        include: Optional[types.quizzesInclude] = None,
        order: Optional[Union[types.quizzesOrderByInput, List[types.quizzesOrderByInput]]] = None,
        distinct: Optional[List[types.quizzesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single quizzes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            quizzes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quizzes model
        order
            Order the returned quizzes records by any field
        distinct
            Filter quizzes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.quizzes
            The first quizzes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second quizzes record ordered by the grade field
        quizzes = await quizzes.prisma().find_first(
            skip=1,
            order={
                'grade': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
        include: Optional[types.quizzesInclude] = None,
        order: Optional[Union[types.quizzesOrderByInput, List[types.quizzesOrderByInput]]] = None,
        distinct: Optional[List[types.quizzesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single quizzes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            quizzes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quizzes model
        order
            Order the returned quizzes records by any field
        distinct
            Filter quizzes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.quizzes
            The first quizzes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second quizzes record ordered by the level field
        quizzes = await quizzes.prisma().find_first_or_raise(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.quizzesUpdateInput,
        where: types.quizzesWhereUniqueInput,
        include: Optional[types.quizzesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single quizzes record.

        Parameters
        ----------
        data
            quizzes record data specifying what to update
        where
            quizzes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The updated quizzes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        quizzes = await quizzes.prisma().update(
            where={
                'id': 1627576247,
            },
            data={
                # data to update the quizzes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.quizzesWhereUniqueInput,
        data: types.quizzesUpsertInput,
        include: Optional[types.quizzesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            quizzes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned quizzes model

        Returns
        -------
        prisma.models.quizzes
            The created or updated quizzes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quizzes = await quizzes.prisma().upsert(
            where={
                'id': 2054802212,
            },
            data={
                'create': {
                    'id': 2054802212,
                    'title': 'ecjjjfbae',
                    'quizId': 'bhhfibbigf',
                    'grade': 'ijdbeffgg',
                    'level': 'jjfeafhfj',
                    'question': 'cbachdgfce',
                    'options': Json({'chbfcacbd': True}),
                    'correct_answer': 'efggddide',
                    'explanation': 'caficfigfb',
                },
                'update': {
                    'title': 'ecjjjfbae',
                    'quizId': 'bhhfibbigf',
                    'grade': 'ijdbeffgg',
                    'level': 'jjfeafhfj',
                    'question': 'cbachdgfce',
                    'options': Json({'chbfcacbd': True}),
                    'correct_answer': 'efggddide',
                    'explanation': 'caficfigfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.quizzesUpdateManyMutationInput,
        where: types.quizzesWhereInput,
    ) -> int:
        """Update multiple quizzes records

        Parameters
        ----------
        data
            quizzes data to update the selected quizzes records to
        where
            Filter to select the quizzes records to update

        Returns
        -------
        int
            The total number of quizzes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all quizzes records
        total = await quizzes.prisma().update_many(
            data={
                'question': 'gaddfhfh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of quizzes records present in the database

        Parameters
        ----------
        select
            Select the quizzes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            quizzes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.quizzesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await quizzes.prisma().count()

        # results: prisma.types.quizzesCountAggregateOutput
        results = await quizzes.prisma().count(
            select={
                '_all': True,
                'options': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.quizzesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
    ) -> types.quizzesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.quizzesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quizzesWhereInput] = None,
        cursor: Optional[types.quizzesWhereUniqueInput] = None,
    ) -> Union[int, types.quizzesCountAggregateOutput]:
        """Count the number of quizzes records present in the database

        Parameters
        ----------
        select
            Select the quizzes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            quizzes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.quizzesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await quizzes.prisma().count()

        # results: prisma.types.quizzesCountAggregateOutput
        results = await quizzes.prisma().count(
            select={
                '_all': True,
                'correct_answer': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.quizzesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.quizzesWhereInput] = None
    ) -> int:
        """Delete multiple quizzes records.

        Parameters
        ----------
        where
            Optional quizzes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of quizzes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all quizzes records
        total = await quizzes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.quizzesScalarFieldKeysT'],
        *,
        where: Optional['types.quizzesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.quizzesAvgAggregateInput'] = None,
        sum: Optional['types.quizzesSumAggregateInput'] = None,
        min: Optional['types.quizzesMinAggregateInput'] = None,
        max: Optional['types.quizzesMaxAggregateInput'] = None,
        having: Optional['types.quizzesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.quizzesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.quizzesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.quizzesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.quizzesGroupByOutput']:
        """Group quizzes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar quizzes fields to group records by
        where
            quizzes filter to select records
        take
            Limit the maximum number of quizzes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.quizzesGroupByOutput]
            A list of dictionaries representing the quizzes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group quizzes records by explanation values
        # and count how many records are in each group
        results = await quizzes.prisma().group_by(
            ['explanation'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class quiz_resultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.quiz_result]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await quiz_result.prisma().query_raw(
            'SELECT * FROM quiz_result WHERE id = $1',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.quiz_result
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await quiz_result.prisma().query_first(
            'SELECT * FROM quiz_result WHERE userId = $1',
            'bgcffadich',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.quiz_resultCreateInput,
        include: Optional[types.quiz_resultInclude] = None
    ) -> _PrismaModelT:
        """Create a new quiz_result record.

        Parameters
        ----------
        data
            quiz_result record data
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The created quiz_result record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a quiz_result record from just the required fields
        quiz_result = await quiz_result.prisma().create(
            data={
                # data to create a quiz_result record
                'userId': 'fcbichhci',
                'correct_answer': 1266032265,
                'Wrong_Answer': 93253262,
                'Total_question': 2053047983,
                'level': 'gifdddbia',
                'Total_Marks': 127474245,
                'score': 948921754,
                'percentage': 1964990155,
                'quizId': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.quiz_resultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple quiz_result records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of quiz_result record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await quiz_result.prisma().create_many(
            data=[
                {
                    # data to create a quiz_result record
                    'userId': 'cffcachfd',
                    'correct_answer': 1223573862,
                    'Wrong_Answer': 541269159,
                    'Total_question': 1064846676,
                    'level': 'faidicegb',
                    'Total_Marks': 1024265714,
                    'score': 872078403,
                    'percentage': 1874748096,
                    'quizId': 'jbgijghgb',
                },
                {
                    # data to create a quiz_result record
                    'userId': 'hgjcghfbi',
                    'correct_answer': 820312479,
                    'Wrong_Answer': 92728044,
                    'Total_question': 344858293,
                    'level': 'bbcbhebbda',
                    'Total_Marks': 1495896251,
                    'score': 208521688,
                    'percentage': 860811569,
                    'quizId': 'bggajdcbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.quiz_resultWhereUniqueInput,
        include: Optional[types.quiz_resultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single quiz_result record.

        Parameters
        ----------
        where
            quiz_result filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The deleted quiz_result record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quiz_result = await quiz_result.prisma().delete(
            where={
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.quiz_resultWhereUniqueInput,
        include: Optional[types.quiz_resultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique quiz_result record.

        Parameters
        ----------
        where
            quiz_result filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The found quiz_result record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quiz_result = await quiz_result.prisma().find_unique(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.quiz_resultWhereUniqueInput,
        include: Optional[types.quiz_resultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique quiz_result record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            quiz_result filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The found quiz_result record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quiz_result = await quiz_result.prisma().find_unique_or_raise(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
        include: Optional[types.quiz_resultInclude] = None,
        order: Optional[Union[types.quiz_resultOrderByInput, List[types.quiz_resultOrderByInput]]] = None,
        distinct: Optional[List[types.quiz_resultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple quiz_result records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of quiz_result records returned
        skip
            Ignore the first N results
        where
            quiz_result filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quiz_result model
        order
            Order the returned quiz_result records by any field
        distinct
            Filter quiz_result records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.quiz_result]
            The list of all quiz_result records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 quiz_result records
        quiz_results = await quiz_result.prisma().find_many(take=10)

        # find the first 5 quiz_result records ordered by the correct_answer field
        quiz_results = await quiz_result.prisma().find_many(
            take=5,
            order={
                'correct_answer': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
        include: Optional[types.quiz_resultInclude] = None,
        order: Optional[Union[types.quiz_resultOrderByInput, List[types.quiz_resultOrderByInput]]] = None,
        distinct: Optional[List[types.quiz_resultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single quiz_result record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            quiz_result filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quiz_result model
        order
            Order the returned quiz_result records by any field
        distinct
            Filter quiz_result records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.quiz_result
            The first quiz_result record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second quiz_result record ordered by the Wrong_Answer field
        quiz_result = await quiz_result.prisma().find_first(
            skip=1,
            order={
                'Wrong_Answer': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
        include: Optional[types.quiz_resultInclude] = None,
        order: Optional[Union[types.quiz_resultOrderByInput, List[types.quiz_resultOrderByInput]]] = None,
        distinct: Optional[List[types.quiz_resultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single quiz_result record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            quiz_result filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned quiz_result model
        order
            Order the returned quiz_result records by any field
        distinct
            Filter quiz_result records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.quiz_result
            The first quiz_result record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second quiz_result record ordered by the Total_question field
        quiz_result = await quiz_result.prisma().find_first_or_raise(
            skip=1,
            order={
                'Total_question': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.quiz_resultUpdateInput,
        where: types.quiz_resultWhereUniqueInput,
        include: Optional[types.quiz_resultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single quiz_result record.

        Parameters
        ----------
        data
            quiz_result record data specifying what to update
        where
            quiz_result filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The updated quiz_result record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        quiz_result = await quiz_result.prisma().update(
            where={
                'id': 'gdjgigfgc',
            },
            data={
                # data to update the quiz_result record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.quiz_resultWhereUniqueInput,
        data: types.quiz_resultUpsertInput,
        include: Optional[types.quiz_resultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            quiz_result filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned quiz_result model

        Returns
        -------
        prisma.models.quiz_result
            The created or updated quiz_result record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quiz_result = await quiz_result.prisma().upsert(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                'create': {
                    'id': 'gfeaahdeh',
                    'userId': 'hgjcghfbi',
                    'correct_answer': 820312479,
                    'Wrong_Answer': 92728044,
                    'Total_question': 344858293,
                    'level': 'bbcbhebbda',
                    'Total_Marks': 1495896251,
                    'score': 208521688,
                    'percentage': 860811569,
                    'quizId': 'bggajdcbbi',
                },
                'update': {
                    'userId': 'hgjcghfbi',
                    'correct_answer': 820312479,
                    'Wrong_Answer': 92728044,
                    'Total_question': 344858293,
                    'level': 'bbcbhebbda',
                    'Total_Marks': 1495896251,
                    'score': 208521688,
                    'percentage': 860811569,
                    'quizId': 'bggajdcbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.quiz_resultUpdateManyMutationInput,
        where: types.quiz_resultWhereInput,
    ) -> int:
        """Update multiple quiz_result records

        Parameters
        ----------
        data
            quiz_result data to update the selected quiz_result records to
        where
            Filter to select the quiz_result records to update

        Returns
        -------
        int
            The total number of quiz_result records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all quiz_result records
        total = await quiz_result.prisma().update_many(
            data={
                'level': 'bjafcgbffc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of quiz_result records present in the database

        Parameters
        ----------
        select
            Select the quiz_result fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            quiz_result filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.quiz_resultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await quiz_result.prisma().count()

        # results: prisma.types.quiz_resultCountAggregateOutput
        results = await quiz_result.prisma().count(
            select={
                '_all': True,
                'Total_Marks': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.quiz_resultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
    ) -> types.quiz_resultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.quiz_resultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.quiz_resultWhereInput] = None,
        cursor: Optional[types.quiz_resultWhereUniqueInput] = None,
    ) -> Union[int, types.quiz_resultCountAggregateOutput]:
        """Count the number of quiz_result records present in the database

        Parameters
        ----------
        select
            Select the quiz_result fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            quiz_result filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.quiz_resultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await quiz_result.prisma().count()

        # results: prisma.types.quiz_resultCountAggregateOutput
        results = await quiz_result.prisma().count(
            select={
                '_all': True,
                'score': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.quiz_resultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.quiz_resultWhereInput] = None
    ) -> int:
        """Delete multiple quiz_result records.

        Parameters
        ----------
        where
            Optional quiz_result filter to find the records to be deleted

        Returns
        -------
        int
            The total number of quiz_result records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all quiz_result records
        total = await quiz_result.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.quiz_resultScalarFieldKeysT'],
        *,
        where: Optional['types.quiz_resultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.quiz_resultAvgAggregateInput'] = None,
        sum: Optional['types.quiz_resultSumAggregateInput'] = None,
        min: Optional['types.quiz_resultMinAggregateInput'] = None,
        max: Optional['types.quiz_resultMaxAggregateInput'] = None,
        having: Optional['types.quiz_resultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.quiz_resultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.quiz_resultScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.quiz_resultScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.quiz_resultGroupByOutput']:
        """Group quiz_result records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar quiz_result fields to group records by
        where
            quiz_result filter to select records
        take
            Limit the maximum number of quiz_result records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.quiz_resultGroupByOutput]
            A list of dictionaries representing the quiz_result record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group quiz_result records by percentage values
        # and count how many records are in each group
        results = await quiz_result.prisma().group_by(
            ['percentage'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class user_progressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.user_progress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await user_progress.prisma().query_raw(
            'SELECT * FROM user_progress WHERE id = $1',
            'hihegjif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.user_progress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await user_progress.prisma().query_first(
            'SELECT * FROM user_progress WHERE userId = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.user_progressCreateInput,
        include: Optional[types.user_progressInclude] = None
    ) -> _PrismaModelT:
        """Create a new user_progress record.

        Parameters
        ----------
        data
            user_progress record data
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The created user_progress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a user_progress record from just the required fields
        user_progress = await user_progress.prisma().create(
            data={
                # data to create a user_progress record
                'userId': 'ifgaaagff',
                'grade': 'befcddgjce',
                'Exp': 1573199653,
                'Level': 2013903098,
                'Badges': Json({'faajgfadf': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.user_progressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple user_progress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of user_progress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await user_progress.prisma().create_many(
            data=[
                {
                    # data to create a user_progress record
                    'userId': 'biaagcedjc',
                    'grade': 'cahhaghecf',
                    'Exp': 1672112838,
                    'Level': 926677639,
                    'Badges': Json({'beehgcebbg': True}),
                },
                {
                    # data to create a user_progress record
                    'userId': 'bhdiaidiaf',
                    'grade': 'deajegcfi',
                    'Exp': 601077795,
                    'Level': 290603296,
                    'Badges': Json({'bifficggej': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.user_progressWhereUniqueInput,
        include: Optional[types.user_progressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single user_progress record.

        Parameters
        ----------
        where
            user_progress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The deleted user_progress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_progress = await user_progress.prisma().delete(
            where={
                'id': 'bgbbaajbic',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.user_progressWhereUniqueInput,
        include: Optional[types.user_progressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique user_progress record.

        Parameters
        ----------
        where
            user_progress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The found user_progress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_progress = await user_progress.prisma().find_unique(
            where={
                'id': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.user_progressWhereUniqueInput,
        include: Optional[types.user_progressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique user_progress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            user_progress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The found user_progress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_progress = await user_progress.prisma().find_unique_or_raise(
            where={
                'id': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
        include: Optional[types.user_progressInclude] = None,
        order: Optional[Union[types.user_progressOrderByInput, List[types.user_progressOrderByInput]]] = None,
        distinct: Optional[List[types.user_progressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple user_progress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of user_progress records returned
        skip
            Ignore the first N results
        where
            user_progress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_progress model
        order
            Order the returned user_progress records by any field
        distinct
            Filter user_progress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.user_progress]
            The list of all user_progress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 user_progress records
        user_progress = await user_progress.prisma().find_many(take=10)

        # find the first 5 user_progress records ordered by the grade field
        user_progress = await user_progress.prisma().find_many(
            take=5,
            order={
                'grade': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
        include: Optional[types.user_progressInclude] = None,
        order: Optional[Union[types.user_progressOrderByInput, List[types.user_progressOrderByInput]]] = None,
        distinct: Optional[List[types.user_progressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single user_progress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user_progress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_progress model
        order
            Order the returned user_progress records by any field
        distinct
            Filter user_progress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user_progress
            The first user_progress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user_progress record ordered by the Exp field
        user_progress = await user_progress.prisma().find_first(
            skip=1,
            order={
                'Exp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
        include: Optional[types.user_progressInclude] = None,
        order: Optional[Union[types.user_progressOrderByInput, List[types.user_progressOrderByInput]]] = None,
        distinct: Optional[List[types.user_progressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single user_progress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user_progress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_progress model
        order
            Order the returned user_progress records by any field
        distinct
            Filter user_progress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user_progress
            The first user_progress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user_progress record ordered by the Level field
        user_progress = await user_progress.prisma().find_first_or_raise(
            skip=1,
            order={
                'Level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.user_progressUpdateInput,
        where: types.user_progressWhereUniqueInput,
        include: Optional[types.user_progressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single user_progress record.

        Parameters
        ----------
        data
            user_progress record data specifying what to update
        where
            user_progress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The updated user_progress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user_progress = await user_progress.prisma().update(
            where={
                'id': 'gdcgcgagj',
            },
            data={
                # data to update the user_progress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.user_progressWhereUniqueInput,
        data: types.user_progressUpsertInput,
        include: Optional[types.user_progressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            user_progress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned user_progress model

        Returns
        -------
        prisma.models.user_progress
            The created or updated user_progress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_progress = await user_progress.prisma().upsert(
            where={
                'id': 'bhceabbgja',
            },
            data={
                'create': {
                    'id': 'bhceabbgja',
                    'userId': 'bhdiaidiaf',
                    'grade': 'deajegcfi',
                    'Exp': 601077795,
                    'Level': 290603296,
                    'Badges': Json({'bifficggej': True}),
                },
                'update': {
                    'userId': 'bhdiaidiaf',
                    'grade': 'deajegcfi',
                    'Exp': 601077795,
                    'Level': 290603296,
                    'Badges': Json({'bifficggej': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.user_progressUpdateManyMutationInput,
        where: types.user_progressWhereInput,
    ) -> int:
        """Update multiple user_progress records

        Parameters
        ----------
        data
            user_progress data to update the selected user_progress records to
        where
            Filter to select the user_progress records to update

        Returns
        -------
        int
            The total number of user_progress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all user_progress records
        total = await user_progress.prisma().update_many(
            data={
                'Badges': Json({'ehabfhegh': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of user_progress records present in the database

        Parameters
        ----------
        select
            Select the user_progress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user_progress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.user_progressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await user_progress.prisma().count()

        # results: prisma.types.user_progressCountAggregateOutput
        results = await user_progress.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.user_progressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
    ) -> types.user_progressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.user_progressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_progressWhereInput] = None,
        cursor: Optional[types.user_progressWhereUniqueInput] = None,
    ) -> Union[int, types.user_progressCountAggregateOutput]:
        """Count the number of user_progress records present in the database

        Parameters
        ----------
        select
            Select the user_progress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user_progress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.user_progressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await user_progress.prisma().count()

        # results: prisma.types.user_progressCountAggregateOutput
        results = await user_progress.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.user_progressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.user_progressWhereInput] = None
    ) -> int:
        """Delete multiple user_progress records.

        Parameters
        ----------
        where
            Optional user_progress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of user_progress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all user_progress records
        total = await user_progress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.user_progressScalarFieldKeysT'],
        *,
        where: Optional['types.user_progressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.user_progressAvgAggregateInput'] = None,
        sum: Optional['types.user_progressSumAggregateInput'] = None,
        min: Optional['types.user_progressMinAggregateInput'] = None,
        max: Optional['types.user_progressMaxAggregateInput'] = None,
        having: Optional['types.user_progressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.user_progressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.user_progressScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.user_progressScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.user_progressGroupByOutput']:
        """Group user_progress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar user_progress fields to group records by
        where
            user_progress filter to select records
        take
            Limit the maximum number of user_progress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.user_progressGroupByOutput]
            A list of dictionaries representing the user_progress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group user_progress records by id values
        # and count how many records are in each group
        results = await user_progress.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class bookmark_quizActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.bookmark_quiz]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await bookmark_quiz.prisma().query_raw(
            'SELECT * FROM bookmark_quiz WHERE id = $1',
            'bcajcajjbc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.bookmark_quiz
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await bookmark_quiz.prisma().query_first(
            'SELECT * FROM bookmark_quiz WHERE userId = $1',
            'bfdgheeegf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.bookmark_quizCreateInput,
        include: Optional[types.bookmark_quizInclude] = None
    ) -> _PrismaModelT:
        """Create a new bookmark_quiz record.

        Parameters
        ----------
        data
            bookmark_quiz record data
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The created bookmark_quiz record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a bookmark_quiz record from just the required fields
        bookmark_quiz = await bookmark_quiz.prisma().create(
            data={
                # data to create a bookmark_quiz record
                'userId': 'ececbijji',
                'quizId': 'cbcfgdcdhf',
                'level': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.bookmark_quizCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple bookmark_quiz records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of bookmark_quiz record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await bookmark_quiz.prisma().create_many(
            data=[
                {
                    # data to create a bookmark_quiz record
                    'userId': 'jcehcdchh',
                    'quizId': 'bgcbjdhjcc',
                    'level': 'bieiidcabj',
                },
                {
                    # data to create a bookmark_quiz record
                    'userId': 'bjcbfcieaa',
                    'quizId': 'cbaaechiej',
                    'level': 'iejbeaaeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.bookmark_quizWhereUniqueInput,
        include: Optional[types.bookmark_quizInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single bookmark_quiz record.

        Parameters
        ----------
        where
            bookmark_quiz filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The deleted bookmark_quiz record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark_quiz = await bookmark_quiz.prisma().delete(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.bookmark_quizWhereUniqueInput,
        include: Optional[types.bookmark_quizInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique bookmark_quiz record.

        Parameters
        ----------
        where
            bookmark_quiz filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The found bookmark_quiz record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark_quiz = await bookmark_quiz.prisma().find_unique(
            where={
                'id': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.bookmark_quizWhereUniqueInput,
        include: Optional[types.bookmark_quizInclude] = None
    ) -> _PrismaModelT:
        """Find a unique bookmark_quiz record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            bookmark_quiz filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The found bookmark_quiz record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark_quiz = await bookmark_quiz.prisma().find_unique_or_raise(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
        include: Optional[types.bookmark_quizInclude] = None,
        order: Optional[Union[types.bookmark_quizOrderByInput, List[types.bookmark_quizOrderByInput]]] = None,
        distinct: Optional[List[types.bookmark_quizScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple bookmark_quiz records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of bookmark_quiz records returned
        skip
            Ignore the first N results
        where
            bookmark_quiz filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model
        order
            Order the returned bookmark_quiz records by any field
        distinct
            Filter bookmark_quiz records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.bookmark_quiz]
            The list of all bookmark_quiz records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 bookmark_quiz records
        bookmark_quizs = await bookmark_quiz.prisma().find_many(take=10)

        # find the first 5 bookmark_quiz records ordered by the quizId field
        bookmark_quizs = await bookmark_quiz.prisma().find_many(
            take=5,
            order={
                'quizId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
        include: Optional[types.bookmark_quizInclude] = None,
        order: Optional[Union[types.bookmark_quizOrderByInput, List[types.bookmark_quizOrderByInput]]] = None,
        distinct: Optional[List[types.bookmark_quizScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single bookmark_quiz record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            bookmark_quiz filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model
        order
            Order the returned bookmark_quiz records by any field
        distinct
            Filter bookmark_quiz records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.bookmark_quiz
            The first bookmark_quiz record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second bookmark_quiz record ordered by the level field
        bookmark_quiz = await bookmark_quiz.prisma().find_first(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
        include: Optional[types.bookmark_quizInclude] = None,
        order: Optional[Union[types.bookmark_quizOrderByInput, List[types.bookmark_quizOrderByInput]]] = None,
        distinct: Optional[List[types.bookmark_quizScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single bookmark_quiz record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            bookmark_quiz filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model
        order
            Order the returned bookmark_quiz records by any field
        distinct
            Filter bookmark_quiz records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.bookmark_quiz
            The first bookmark_quiz record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second bookmark_quiz record ordered by the id field
        bookmark_quiz = await bookmark_quiz.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.bookmark_quizUpdateInput,
        where: types.bookmark_quizWhereUniqueInput,
        include: Optional[types.bookmark_quizInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single bookmark_quiz record.

        Parameters
        ----------
        data
            bookmark_quiz record data specifying what to update
        where
            bookmark_quiz filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The updated bookmark_quiz record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bookmark_quiz = await bookmark_quiz.prisma().update(
            where={
                'id': 'fbahdheji',
            },
            data={
                # data to update the bookmark_quiz record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.bookmark_quizWhereUniqueInput,
        data: types.bookmark_quizUpsertInput,
        include: Optional[types.bookmark_quizInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            bookmark_quiz filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned bookmark_quiz model

        Returns
        -------
        prisma.models.bookmark_quiz
            The created or updated bookmark_quiz record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark_quiz = await bookmark_quiz.prisma().upsert(
            where={
                'id': 'cbbheiicgh',
            },
            data={
                'create': {
                    'id': 'cbbheiicgh',
                    'userId': 'bjcbfcieaa',
                    'quizId': 'cbaaechiej',
                    'level': 'iejbeaaeg',
                },
                'update': {
                    'userId': 'bjcbfcieaa',
                    'quizId': 'cbaaechiej',
                    'level': 'iejbeaaeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.bookmark_quizUpdateManyMutationInput,
        where: types.bookmark_quizWhereInput,
    ) -> int:
        """Update multiple bookmark_quiz records

        Parameters
        ----------
        data
            bookmark_quiz data to update the selected bookmark_quiz records to
        where
            Filter to select the bookmark_quiz records to update

        Returns
        -------
        int
            The total number of bookmark_quiz records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all bookmark_quiz records
        total = await bookmark_quiz.prisma().update_many(
            data={
                'userId': 'beabjeejdg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
    ) -> int:
        """Count the number of bookmark_quiz records present in the database

        Parameters
        ----------
        select
            Select the bookmark_quiz fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            bookmark_quiz filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.bookmark_quizCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await bookmark_quiz.prisma().count()

        # results: prisma.types.bookmark_quizCountAggregateOutput
        results = await bookmark_quiz.prisma().count(
            select={
                '_all': True,
                'quizId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.bookmark_quizCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
    ) -> types.bookmark_quizCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.bookmark_quizCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmark_quizWhereInput] = None,
        cursor: Optional[types.bookmark_quizWhereUniqueInput] = None,
    ) -> Union[int, types.bookmark_quizCountAggregateOutput]:
        """Count the number of bookmark_quiz records present in the database

        Parameters
        ----------
        select
            Select the bookmark_quiz fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            bookmark_quiz filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.bookmark_quizCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await bookmark_quiz.prisma().count()

        # results: prisma.types.bookmark_quizCountAggregateOutput
        results = await bookmark_quiz.prisma().count(
            select={
                '_all': True,
                'level': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.bookmark_quizCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.bookmark_quizWhereInput] = None
    ) -> int:
        """Delete multiple bookmark_quiz records.

        Parameters
        ----------
        where
            Optional bookmark_quiz filter to find the records to be deleted

        Returns
        -------
        int
            The total number of bookmark_quiz records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all bookmark_quiz records
        total = await bookmark_quiz.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.bookmark_quizScalarFieldKeysT'],
        *,
        where: Optional['types.bookmark_quizWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.bookmark_quizAvgAggregateInput'] = None,
        sum: Optional['types.bookmark_quizSumAggregateInput'] = None,
        min: Optional['types.bookmark_quizMinAggregateInput'] = None,
        max: Optional['types.bookmark_quizMaxAggregateInput'] = None,
        having: Optional['types.bookmark_quizScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.bookmark_quizCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.bookmark_quizScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.bookmark_quizScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.bookmark_quizGroupByOutput']:
        """Group bookmark_quiz records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar bookmark_quiz fields to group records by
        where
            bookmark_quiz filter to select records
        take
            Limit the maximum number of bookmark_quiz records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.bookmark_quizGroupByOutput]
            A list of dictionaries representing the bookmark_quiz record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group bookmark_quiz records by id values
        # and count how many records are in each group
        results = await bookmark_quiz.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DebateSessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DebateSession]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DebateSession.prisma().query_raw(
            'SELECT * FROM DebateSession WHERE id = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DebateSession
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DebateSession.prisma().query_first(
            'SELECT * FROM DebateSession WHERE topic = $1',
            'fbjeiiffa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DebateSessionCreateInput,
        include: Optional[types.DebateSessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new DebateSession record.

        Parameters
        ----------
        data
            DebateSession record data
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The created DebateSession record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DebateSession record from just the required fields
        debatesession = await DebateSession.prisma().create(
            data={
                # data to create a DebateSession record
                'topic': 'jhgidcgbf',
                'duration': 1696425492,
                'userId': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DebateSessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DebateSession records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DebateSession record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DebateSession.prisma().create_many(
            data=[
                {
                    # data to create a DebateSession record
                    'topic': 'bacdaibgfa',
                    'duration': 327681027,
                    'userId': 'fchheijjc',
                },
                {
                    # data to create a DebateSession record
                    'topic': 'cacjdfhejh',
                    'duration': 1318597118,
                    'userId': 'cbccbbcdfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DebateSessionWhereUniqueInput,
        include: Optional[types.DebateSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DebateSession record.

        Parameters
        ----------
        where
            DebateSession filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The deleted DebateSession record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        debatesession = await DebateSession.prisma().delete(
            where={
                'id': 'bacejedaca',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DebateSessionWhereUniqueInput,
        include: Optional[types.DebateSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DebateSession record.

        Parameters
        ----------
        where
            DebateSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The found DebateSession record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        debatesession = await DebateSession.prisma().find_unique(
            where={
                'id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DebateSessionWhereUniqueInput,
        include: Optional[types.DebateSessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DebateSession record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DebateSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The found DebateSession record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        debatesession = await DebateSession.prisma().find_unique_or_raise(
            where={
                'id': 'bfjibceaec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
        include: Optional[types.DebateSessionInclude] = None,
        order: Optional[Union[types.DebateSessionOrderByInput, List[types.DebateSessionOrderByInput]]] = None,
        distinct: Optional[List[types.DebateSessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DebateSession records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DebateSession records returned
        skip
            Ignore the first N results
        where
            DebateSession filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DebateSession model
        order
            Order the returned DebateSession records by any field
        distinct
            Filter DebateSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DebateSession]
            The list of all DebateSession records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DebateSession records
        debatesessions = await DebateSession.prisma().find_many(take=10)

        # find the first 5 DebateSession records ordered by the duration field
        debatesessions = await DebateSession.prisma().find_many(
            take=5,
            order={
                'duration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
        include: Optional[types.DebateSessionInclude] = None,
        order: Optional[Union[types.DebateSessionOrderByInput, List[types.DebateSessionOrderByInput]]] = None,
        distinct: Optional[List[types.DebateSessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DebateSession record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DebateSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DebateSession model
        order
            Order the returned DebateSession records by any field
        distinct
            Filter DebateSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DebateSession
            The first DebateSession record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DebateSession record ordered by the startTime field
        debatesession = await DebateSession.prisma().find_first(
            skip=1,
            order={
                'startTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
        include: Optional[types.DebateSessionInclude] = None,
        order: Optional[Union[types.DebateSessionOrderByInput, List[types.DebateSessionOrderByInput]]] = None,
        distinct: Optional[List[types.DebateSessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DebateSession record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DebateSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DebateSession model
        order
            Order the returned DebateSession records by any field
        distinct
            Filter DebateSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DebateSession
            The first DebateSession record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DebateSession record ordered by the endTime field
        debatesession = await DebateSession.prisma().find_first_or_raise(
            skip=1,
            order={
                'endTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DebateSessionUpdateInput,
        where: types.DebateSessionWhereUniqueInput,
        include: Optional[types.DebateSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DebateSession record.

        Parameters
        ----------
        data
            DebateSession record data specifying what to update
        where
            DebateSession filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The updated DebateSession record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        debatesession = await DebateSession.prisma().update(
            where={
                'id': 'ibhgcdbgd',
            },
            data={
                # data to update the DebateSession record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DebateSessionWhereUniqueInput,
        data: types.DebateSessionUpsertInput,
        include: Optional[types.DebateSessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DebateSession filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DebateSession model

        Returns
        -------
        prisma.models.DebateSession
            The created or updated DebateSession record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        debatesession = await DebateSession.prisma().upsert(
            where={
                'id': 'badaffhddg',
            },
            data={
                'create': {
                    'id': 'badaffhddg',
                    'topic': 'cacjdfhejh',
                    'duration': 1318597118,
                    'userId': 'cbccbbcdfb',
                },
                'update': {
                    'topic': 'cacjdfhejh',
                    'duration': 1318597118,
                    'userId': 'cbccbbcdfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DebateSessionUpdateManyMutationInput,
        where: types.DebateSessionWhereInput,
    ) -> int:
        """Update multiple DebateSession records

        Parameters
        ----------
        data
            DebateSession data to update the selected DebateSession records to
        where
            Filter to select the DebateSession records to update

        Returns
        -------
        int
            The total number of DebateSession records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DebateSession records
        total = await DebateSession.prisma().update_many(
            data={
                'userId': 'bbdbfcfihd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DebateSession records present in the database

        Parameters
        ----------
        select
            Select the DebateSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DebateSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DebateSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DebateSession.prisma().count()

        # results: prisma.types.DebateSessionCountAggregateOutput
        results = await DebateSession.prisma().count(
            select={
                '_all': True,
                'winner': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DebateSessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
    ) -> types.DebateSessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DebateSessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DebateSessionWhereInput] = None,
        cursor: Optional[types.DebateSessionWhereUniqueInput] = None,
    ) -> Union[int, types.DebateSessionCountAggregateOutput]:
        """Count the number of DebateSession records present in the database

        Parameters
        ----------
        select
            Select the DebateSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DebateSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DebateSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DebateSession.prisma().count()

        # results: prisma.types.DebateSessionCountAggregateOutput
        results = await DebateSession.prisma().count(
            select={
                '_all': True,
                'feedback': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DebateSessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DebateSessionWhereInput] = None
    ) -> int:
        """Delete multiple DebateSession records.

        Parameters
        ----------
        where
            Optional DebateSession filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DebateSession records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DebateSession records
        total = await DebateSession.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DebateSessionScalarFieldKeysT'],
        *,
        where: Optional['types.DebateSessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DebateSessionAvgAggregateInput'] = None,
        sum: Optional['types.DebateSessionSumAggregateInput'] = None,
        min: Optional['types.DebateSessionMinAggregateInput'] = None,
        max: Optional['types.DebateSessionMaxAggregateInput'] = None,
        having: Optional['types.DebateSessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DebateSessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DebateSessionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.DebateSessionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.DebateSessionGroupByOutput']:
        """Group DebateSession records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DebateSession fields to group records by
        where
            DebateSession filter to select records
        take
            Limit the maximum number of DebateSession records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DebateSessionGroupByOutput]
            A list of dictionaries representing the DebateSession record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DebateSession records by createdAt values
        # and count how many records are in each group
        results = await DebateSession.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE sessionId = $1',
            'bchgafhjed',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'sessionId': 'heffgjdei',
                'role': 'dahihgbeb',
                'content': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'sessionId': 'bfcgifeged',
                    'role': 'jfiahhbae',
                    'content': 'bfbdafajcb',
                },
                {
                    # data to create a Message record
                    'sessionId': 'caeghehde',
                    'role': 'caghgfbggd',
                    'content': 'bbidjbbjaa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'bfijhaejdd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'bcedehfiji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'bdgjicijhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the role field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the content field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the createdAt field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'bghifjdeia',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'eadfcbbcb',
            },
            data={
                'create': {
                    'id': 'eadfcbbcb',
                    'sessionId': 'caeghehde',
                    'role': 'caghgfbggd',
                    'content': 'bbidjbbjaa',
                },
                'update': {
                    'sessionId': 'caeghehde',
                    'role': 'caghgfbggd',
                    'content': 'bbidjbbjaa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'id': 'geihgahba'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeysT'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by content values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class companion_createActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.companion_create]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await companion_create.prisma().query_raw(
            'SELECT * FROM companion_create WHERE id = $1',
            'gahdcdhbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.companion_create
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await companion_create.prisma().query_first(
            'SELECT * FROM companion_create WHERE userId = $1',
            'begiijahea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.companion_createCreateInput,
        include: Optional[types.companion_createInclude] = None
    ) -> _PrismaModelT:
        """Create a new companion_create record.

        Parameters
        ----------
        data
            companion_create record data
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The created companion_create record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a companion_create record from just the required fields
        companion_create = await companion_create.prisma().create(
            data={
                # data to create a companion_create record
                'userId': 'gcjadjaaf',
                'topic': 'bcbebgiaic',
                'level': 'ijigbdcbj',
                'duration': 'gfidhicai',
                'voice': 'jfegcaafh',
                'tone': 'bcbeiajjfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.companion_createCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple companion_create records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of companion_create record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await companion_create.prisma().create_many(
            data=[
                {
                    # data to create a companion_create record
                    'userId': 'baehicaajf',
                    'topic': 'bdachdeiga',
                    'level': 'ijdafccef',
                    'duration': 'ciaaiddag',
                    'voice': 'fejggijff',
                    'tone': 'hghjaaai',
                },
                {
                    # data to create a companion_create record
                    'userId': 'cajicjjdef',
                    'topic': 'cefjaadec',
                    'level': 'ibbigdigd',
                    'duration': 'bdiiiabbii',
                    'voice': 'hfcfhhadh',
                    'tone': 'bbihggdcji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.companion_createWhereUniqueInput,
        include: Optional[types.companion_createInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single companion_create record.

        Parameters
        ----------
        where
            companion_create filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The deleted companion_create record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companion_create = await companion_create.prisma().delete(
            where={
                'id': 'hgjgibdgd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.companion_createWhereUniqueInput,
        include: Optional[types.companion_createInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique companion_create record.

        Parameters
        ----------
        where
            companion_create filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The found companion_create record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companion_create = await companion_create.prisma().find_unique(
            where={
                'id': 'bcbecjfice',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.companion_createWhereUniqueInput,
        include: Optional[types.companion_createInclude] = None
    ) -> _PrismaModelT:
        """Find a unique companion_create record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            companion_create filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The found companion_create record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companion_create = await companion_create.prisma().find_unique_or_raise(
            where={
                'id': 'bacbebhjjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
        include: Optional[types.companion_createInclude] = None,
        order: Optional[Union[types.companion_createOrderByInput, List[types.companion_createOrderByInput]]] = None,
        distinct: Optional[List[types.companion_createScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple companion_create records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of companion_create records returned
        skip
            Ignore the first N results
        where
            companion_create filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned companion_create model
        order
            Order the returned companion_create records by any field
        distinct
            Filter companion_create records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.companion_create]
            The list of all companion_create records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 companion_create records
        companion_creates = await companion_create.prisma().find_many(take=10)

        # find the first 5 companion_create records ordered by the topic field
        companion_creates = await companion_create.prisma().find_many(
            take=5,
            order={
                'topic': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
        include: Optional[types.companion_createInclude] = None,
        order: Optional[Union[types.companion_createOrderByInput, List[types.companion_createOrderByInput]]] = None,
        distinct: Optional[List[types.companion_createScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single companion_create record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            companion_create filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned companion_create model
        order
            Order the returned companion_create records by any field
        distinct
            Filter companion_create records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.companion_create
            The first companion_create record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second companion_create record ordered by the level field
        companion_create = await companion_create.prisma().find_first(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
        include: Optional[types.companion_createInclude] = None,
        order: Optional[Union[types.companion_createOrderByInput, List[types.companion_createOrderByInput]]] = None,
        distinct: Optional[List[types.companion_createScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single companion_create record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            companion_create filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned companion_create model
        order
            Order the returned companion_create records by any field
        distinct
            Filter companion_create records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.companion_create
            The first companion_create record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second companion_create record ordered by the duration field
        companion_create = await companion_create.prisma().find_first_or_raise(
            skip=1,
            order={
                'duration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.companion_createUpdateInput,
        where: types.companion_createWhereUniqueInput,
        include: Optional[types.companion_createInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single companion_create record.

        Parameters
        ----------
        data
            companion_create record data specifying what to update
        where
            companion_create filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The updated companion_create record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        companion_create = await companion_create.prisma().update(
            where={
                'id': 'dfbfaddhe',
            },
            data={
                # data to update the companion_create record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.companion_createWhereUniqueInput,
        data: types.companion_createUpsertInput,
        include: Optional[types.companion_createInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            companion_create filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned companion_create model

        Returns
        -------
        prisma.models.companion_create
            The created or updated companion_create record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companion_create = await companion_create.prisma().upsert(
            where={
                'id': 'bdcbbieibf',
            },
            data={
                'create': {
                    'id': 'bdcbbieibf',
                    'userId': 'cajicjjdef',
                    'topic': 'cefjaadec',
                    'level': 'ibbigdigd',
                    'duration': 'bdiiiabbii',
                    'voice': 'hfcfhhadh',
                    'tone': 'bbihggdcji',
                },
                'update': {
                    'userId': 'cajicjjdef',
                    'topic': 'cefjaadec',
                    'level': 'ibbigdigd',
                    'duration': 'bdiiiabbii',
                    'voice': 'hfcfhhadh',
                    'tone': 'bbihggdcji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.companion_createUpdateManyMutationInput,
        where: types.companion_createWhereInput,
    ) -> int:
        """Update multiple companion_create records

        Parameters
        ----------
        data
            companion_create data to update the selected companion_create records to
        where
            Filter to select the companion_create records to update

        Returns
        -------
        int
            The total number of companion_create records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all companion_create records
        total = await companion_create.prisma().update_many(
            data={
                'voice': 'dgjhdcggi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
    ) -> int:
        """Count the number of companion_create records present in the database

        Parameters
        ----------
        select
            Select the companion_create fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            companion_create filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.companion_createCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await companion_create.prisma().count()

        # results: prisma.types.companion_createCountAggregateOutput
        results = await companion_create.prisma().count(
            select={
                '_all': True,
                'tone': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.companion_createCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
    ) -> types.companion_createCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.companion_createCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.companion_createWhereInput] = None,
        cursor: Optional[types.companion_createWhereUniqueInput] = None,
    ) -> Union[int, types.companion_createCountAggregateOutput]:
        """Count the number of companion_create records present in the database

        Parameters
        ----------
        select
            Select the companion_create fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            companion_create filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.companion_createCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await companion_create.prisma().count()

        # results: prisma.types.companion_createCountAggregateOutput
        results = await companion_create.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.companion_createCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.companion_createWhereInput] = None
    ) -> int:
        """Delete multiple companion_create records.

        Parameters
        ----------
        where
            Optional companion_create filter to find the records to be deleted

        Returns
        -------
        int
            The total number of companion_create records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all companion_create records
        total = await companion_create.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.companion_createScalarFieldKeysT'],
        *,
        where: Optional['types.companion_createWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.companion_createAvgAggregateInput'] = None,
        sum: Optional['types.companion_createSumAggregateInput'] = None,
        min: Optional['types.companion_createMinAggregateInput'] = None,
        max: Optional['types.companion_createMaxAggregateInput'] = None,
        having: Optional['types.companion_createScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.companion_createCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.companion_createScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.companion_createScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.companion_createGroupByOutput']:
        """Group companion_create records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar companion_create fields to group records by
        where
            companion_create filter to select records
        take
            Limit the maximum number of companion_create records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.companion_createGroupByOutput]
            A list of dictionaries representing the companion_create record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group companion_create records by created_at values
        # and count how many records are in each group
        results = await companion_create.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InteractionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Interaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Interaction.prisma().query_raw(
            'SELECT * FROM Interaction WHERE id = $1',
            'bbjbcdfabd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Interaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Interaction.prisma().query_first(
            'SELECT * FROM Interaction WHERE companionId = $1',
            'gchfgbcec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InteractionCreateInput,
        include: Optional[types.InteractionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Interaction record.

        Parameters
        ----------
        data
            Interaction record data
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The created Interaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Interaction record from just the required fields
        interaction = await Interaction.prisma().create(
            data={
                # data to create a Interaction record
                'companionId': 'bihcjfcjah',
                'userInput': 'bhjdcicaii',
                'companionResponse': 'bibedjhcej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InteractionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Interaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Interaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Interaction.prisma().create_many(
            data=[
                {
                    # data to create a Interaction record
                    'companionId': 'bjcdajabfa',
                    'userInput': 'bchhceeeff',
                    'companionResponse': 'bbgaifhdaa',
                },
                {
                    # data to create a Interaction record
                    'companionId': 'dgbcdaegb',
                    'userInput': 'beagfbbjig',
                    'companionResponse': 'beicihhijb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InteractionWhereUniqueInput,
        include: Optional[types.InteractionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Interaction record.

        Parameters
        ----------
        where
            Interaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The deleted Interaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interaction = await Interaction.prisma().delete(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InteractionWhereUniqueInput,
        include: Optional[types.InteractionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Interaction record.

        Parameters
        ----------
        where
            Interaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The found Interaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interaction = await Interaction.prisma().find_unique(
            where={
                'id': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InteractionWhereUniqueInput,
        include: Optional[types.InteractionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Interaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Interaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The found Interaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interaction = await Interaction.prisma().find_unique_or_raise(
            where={
                'id': 'bhfaabbaha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
        include: Optional[types.InteractionInclude] = None,
        order: Optional[Union[types.InteractionOrderByInput, List[types.InteractionOrderByInput]]] = None,
        distinct: Optional[List[types.InteractionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Interaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Interaction records returned
        skip
            Ignore the first N results
        where
            Interaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interaction model
        order
            Order the returned Interaction records by any field
        distinct
            Filter Interaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Interaction]
            The list of all Interaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Interaction records
        interactions = await Interaction.prisma().find_many(take=10)

        # find the first 5 Interaction records ordered by the userInput field
        interactions = await Interaction.prisma().find_many(
            take=5,
            order={
                'userInput': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
        include: Optional[types.InteractionInclude] = None,
        order: Optional[Union[types.InteractionOrderByInput, List[types.InteractionOrderByInput]]] = None,
        distinct: Optional[List[types.InteractionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Interaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Interaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interaction model
        order
            Order the returned Interaction records by any field
        distinct
            Filter Interaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Interaction
            The first Interaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Interaction record ordered by the companionResponse field
        interaction = await Interaction.prisma().find_first(
            skip=1,
            order={
                'companionResponse': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
        include: Optional[types.InteractionInclude] = None,
        order: Optional[Union[types.InteractionOrderByInput, List[types.InteractionOrderByInput]]] = None,
        distinct: Optional[List[types.InteractionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Interaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Interaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interaction model
        order
            Order the returned Interaction records by any field
        distinct
            Filter Interaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Interaction
            The first Interaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Interaction record ordered by the createdAt field
        interaction = await Interaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InteractionUpdateInput,
        where: types.InteractionWhereUniqueInput,
        include: Optional[types.InteractionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Interaction record.

        Parameters
        ----------
        data
            Interaction record data specifying what to update
        where
            Interaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The updated Interaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        interaction = await Interaction.prisma().update(
            where={
                'id': 'ebajedhhf',
            },
            data={
                # data to update the Interaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InteractionWhereUniqueInput,
        data: types.InteractionUpsertInput,
        include: Optional[types.InteractionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Interaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Interaction model

        Returns
        -------
        prisma.models.Interaction
            The created or updated Interaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interaction = await Interaction.prisma().upsert(
            where={
                'id': 'jajacedge',
            },
            data={
                'create': {
                    'id': 'jajacedge',
                    'companionId': 'dgbcdaegb',
                    'userInput': 'beagfbbjig',
                    'companionResponse': 'beicihhijb',
                },
                'update': {
                    'companionId': 'dgbcdaegb',
                    'userInput': 'beagfbbjig',
                    'companionResponse': 'beicihhijb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InteractionUpdateManyMutationInput,
        where: types.InteractionWhereInput,
    ) -> int:
        """Update multiple Interaction records

        Parameters
        ----------
        data
            Interaction data to update the selected Interaction records to
        where
            Filter to select the Interaction records to update

        Returns
        -------
        int
            The total number of Interaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Interaction records
        total = await Interaction.prisma().update_many(
            data={
                'id': 'hffgbabgf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Interaction records present in the database

        Parameters
        ----------
        select
            Select the Interaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Interaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InteractionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Interaction.prisma().count()

        # results: prisma.types.InteractionCountAggregateOutput
        results = await Interaction.prisma().count(
            select={
                '_all': True,
                'companionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InteractionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
    ) -> types.InteractionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InteractionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InteractionWhereInput] = None,
        cursor: Optional[types.InteractionWhereUniqueInput] = None,
    ) -> Union[int, types.InteractionCountAggregateOutput]:
        """Count the number of Interaction records present in the database

        Parameters
        ----------
        select
            Select the Interaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Interaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InteractionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Interaction.prisma().count()

        # results: prisma.types.InteractionCountAggregateOutput
        results = await Interaction.prisma().count(
            select={
                '_all': True,
                'userInput': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InteractionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InteractionWhereInput] = None
    ) -> int:
        """Delete multiple Interaction records.

        Parameters
        ----------
        where
            Optional Interaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Interaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Interaction records
        total = await Interaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InteractionScalarFieldKeysT'],
        *,
        where: Optional['types.InteractionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InteractionAvgAggregateInput'] = None,
        sum: Optional['types.InteractionSumAggregateInput'] = None,
        min: Optional['types.InteractionMinAggregateInput'] = None,
        max: Optional['types.InteractionMaxAggregateInput'] = None,
        having: Optional['types.InteractionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InteractionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InteractionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.InteractionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.InteractionGroupByOutput']:
        """Group Interaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Interaction fields to group records by
        where
            Interaction filter to select records
        take
            Limit the maximum number of Interaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InteractionGroupByOutput]
            A list of dictionaries representing the Interaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Interaction records by companionResponse values
        # and count how many records are in each group
        results = await Interaction.prisma().group_by(
            ['companionResponse'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models