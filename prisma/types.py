# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    password: Optional[_str]
    imageUrl: Optional[_str]
    quiz_data_result: 'quiz_resultCreateManyNestedWithoutRelationsInput'
    user_progress_report: 'user_progressCreateManyNestedWithoutRelationsInput'
    bookmark: 'bookmark_quizCreateManyNestedWithoutRelationsInput'
    debatePoint: 'DebateSessionCreateManyNestedWithoutRelationsInput'
    companionData: 'companion_createCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    clerk_id: _str
    username: _str
    email: _str
    grade: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    password: Optional[_str]
    imageUrl: Optional[_str]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    clerk_id: _str
    username: _str
    email: _str
    grade: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_clerk_id_Input = TypedDict(
    '_UserWhereUnique_clerk_id_Input',
    {
        'clerk_id': '_str',
    },
    total=True
)

_UserWhereUnique_username_Input = TypedDict(
    '_UserWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_clerk_id_Input',
    '_UserWhereUnique_username_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    clerk_id: _str
    username: _str
    email: _str
    password: Optional[_str]
    grade: _str
    imageUrl: Optional[_str]
    quiz_data_result: 'quiz_resultUpdateManyWithoutRelationsInput'
    user_progress_report: 'user_progressUpdateManyWithoutRelationsInput'
    bookmark: 'bookmark_quizUpdateManyWithoutRelationsInput'
    debatePoint: 'DebateSessionUpdateManyWithoutRelationsInput'
    companionData: 'companion_createUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    clerk_id: _str
    username: _str
    email: _str
    password: Optional[_str]
    grade: _str
    imageUrl: Optional[_str]


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_clerk_id_OrderByInput = TypedDict(
    '_User_clerk_id_OrderByInput',
    {
        'clerk_id': 'SortOrder',
    },
    total=True
)

_User_username_OrderByInput = TypedDict(
    '_User_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_grade_OrderByInput = TypedDict(
    '_User_grade_OrderByInput',
    {
        'grade': 'SortOrder',
    },
    total=True
)

_User_imageUrl_OrderByInput = TypedDict(
    '_User_imageUrl_OrderByInput',
    {
        'imageUrl': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_clerk_id_OrderByInput',
    '_User_username_OrderByInput',
    '_User_email_OrderByInput',
    '_User_password_OrderByInput',
    '_User_grade_OrderByInput',
    '_User_imageUrl_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromUser']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromUser']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromUser']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromUser']
    companionData: Union[bool, 'FindManycompanion_createArgsFromUser']


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromUser']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromUser']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromUser']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromUser']
    companionData: Union[bool, 'FindManycompanion_createArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class quizzesArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class quiz_resultArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class user_progressArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class bookmark_quizArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    messages: Union[bool, 'FindManyMessageArgsFromUser']


class DebateSessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    session: Union[bool, 'DebateSessionArgsFromUser']


class MessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    interactions: Union[bool, 'FindManyInteractionArgsFromUser']
    user: Union[bool, 'UserArgsFromUser']


class companion_createArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    companion: Union[bool, 'companion_createArgsFromUser']


class InteractionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    clerk_id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    grade: Union[_str, 'types.StringFilter']
    imageUrl: Union[None, _str, 'types.StringFilter']
    quiz_data_result: 'quiz_resultListRelationFilter'
    user_progress_report: 'user_progressListRelationFilter'
    bookmark: 'bookmark_quizListRelationFilter'
    debatePoint: 'DebateSessionListRelationFilter'
    companionData: 'companion_createListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    clerk_id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    grade: Union[_str, 'types.StringWithAggregatesFilter']
    imageUrl: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    clerk_id: _str
    username: _str
    email: _str
    password: _str
    grade: _str
    imageUrl: _str
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    clerk_id: _str
    username: _str
    email: _str
    password: _str
    grade: _str
    imageUrl: _str


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    clerk_id: bool
    username: bool
    email: bool
    password: bool
    grade: bool
    imageUrl: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    clerk_id: bool
    username: bool
    email: bool
    password: bool
    grade: bool
    imageUrl: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'clerk_id': bool,
        'username': bool,
        'email': bool,
        'password': bool,
        'grade': bool,
        'imageUrl': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'clerk_id': int,
        'username': int,
        'email': int,
        'password': int,
        'grade': int,
        'imageUrl': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'clerk_id',
    'username',
    'email',
    'password',
    'grade',
    'imageUrl',
    'quiz_data_result',
    'user_progress_report',
    'bookmark',
    'debatePoint',
    'companionData',
]
UserScalarFieldKeys = Literal[
    'id',
    'clerk_id',
    'username',
    'email',
    'password',
    'grade',
    'imageUrl',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'quiz_data_result',
        'user_progress_report',
        'bookmark',
        'debatePoint',
        'companionData',
    ]

# quizzes types

class quizzesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the quizzes create method"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quizzesCreateInput(quizzesOptionalCreateInput):
    """Required arguments to the quizzes create method"""
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class quizzesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the quizzes create method, without relations"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quizzesCreateWithoutRelationsInput(quizzesOptionalCreateWithoutRelationsInput):
    """Required arguments to the quizzes create method, without relations"""
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str

class quizzesConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'quizzesCreateWithoutRelationsInput'
    where: 'quizzesWhereUniqueInput'

class quizzesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'quizzesCreateWithoutRelationsInput'
    connect: 'quizzesWhereUniqueInput'
    connect_or_create: 'quizzesConnectOrCreateWithoutRelationsInput'


class quizzesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['quizzesCreateWithoutRelationsInput', List['quizzesCreateWithoutRelationsInput']]
    connect: Union['quizzesWhereUniqueInput', List['quizzesWhereUniqueInput']]
    connect_or_create: Union['quizzesConnectOrCreateWithoutRelationsInput', List['quizzesConnectOrCreateWithoutRelationsInput']]

_quizzesWhereUnique_id_Input = TypedDict(
    '_quizzesWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

quizzesWhereUniqueInput = _quizzesWhereUnique_id_Input


class quizzesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quizzesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quizzesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['quizzesCreateWithoutRelationsInput']
    connect: List['quizzesWhereUniqueInput']
    connect_or_create: List['quizzesConnectOrCreateWithoutRelationsInput']
    set: List['quizzesWhereUniqueInput']
    disconnect: List['quizzesWhereUniqueInput']
    delete: List['quizzesWhereUniqueInput']

    # TODO
    # update: List['quizzesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['quizzesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['quizzesScalarWhereInput']
    # upsert: List['quizzesUpserteWithWhereUniqueWithoutRelationsInput']


class quizzesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'quizzesCreateWithoutRelationsInput'
    connect: 'quizzesWhereUniqueInput'
    connect_or_create: 'quizzesConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'quizzesUpdateInput'
    # upsert: 'quizzesUpsertWithoutRelationsInput'


class quizzesUpsertInput(TypedDict):
    create: 'quizzesCreateInput'
    update: 'quizzesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_quizzes_id_OrderByInput = TypedDict(
    '_quizzes_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_quizzes_title_OrderByInput = TypedDict(
    '_quizzes_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_quizzes_quizId_OrderByInput = TypedDict(
    '_quizzes_quizId_OrderByInput',
    {
        'quizId': 'SortOrder',
    },
    total=True
)

_quizzes_grade_OrderByInput = TypedDict(
    '_quizzes_grade_OrderByInput',
    {
        'grade': 'SortOrder',
    },
    total=True
)

_quizzes_level_OrderByInput = TypedDict(
    '_quizzes_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_quizzes_question_OrderByInput = TypedDict(
    '_quizzes_question_OrderByInput',
    {
        'question': 'SortOrder',
    },
    total=True
)

_quizzes_options_OrderByInput = TypedDict(
    '_quizzes_options_OrderByInput',
    {
        'options': 'SortOrder',
    },
    total=True
)

_quizzes_correct_answer_OrderByInput = TypedDict(
    '_quizzes_correct_answer_OrderByInput',
    {
        'correct_answer': 'SortOrder',
    },
    total=True
)

_quizzes_explanation_OrderByInput = TypedDict(
    '_quizzes_explanation_OrderByInput',
    {
        'explanation': 'SortOrder',
    },
    total=True
)

_quizzes_created_at_OrderByInput = TypedDict(
    '_quizzes_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_quizzes_updated_at_OrderByInput = TypedDict(
    '_quizzes_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_quizzes_RelevanceInner = TypedDict(
    '_quizzes_RelevanceInner',
    {
        'fields': 'List[quizzesScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_quizzes_RelevanceOrderByInput = TypedDict(
    '_quizzes_RelevanceOrderByInput',
    {
        '_relevance': '_quizzes_RelevanceInner',
    },
    total=True
)

quizzesOrderByInput = Union[
    '_quizzes_id_OrderByInput',
    '_quizzes_title_OrderByInput',
    '_quizzes_quizId_OrderByInput',
    '_quizzes_grade_OrderByInput',
    '_quizzes_level_OrderByInput',
    '_quizzes_question_OrderByInput',
    '_quizzes_options_OrderByInput',
    '_quizzes_correct_answer_OrderByInput',
    '_quizzes_explanation_OrderByInput',
    '_quizzes_created_at_OrderByInput',
    '_quizzes_updated_at_OrderByInput',
    '_quizzes_RelevanceOrderByInput',
]



# recursive quizzes types
# TODO: cleanup these types



quizzesRelationFilter = TypedDict(
    'quizzesRelationFilter',
    {
        'is': 'quizzesWhereInput',
        'is_not': 'quizzesWhereInput',
    },
    total=False,
)


class quizzesListRelationFilter(TypedDict, total=False):
    some: 'quizzesWhereInput'
    none: 'quizzesWhereInput'
    every: 'quizzesWhereInput'


class quizzesInclude(TypedDict, total=False):
    """quizzes relational arguments"""


class UserIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromquizzes']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromquizzes']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromquizzes']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromquizzes']
    companionData: Union[bool, 'FindManycompanion_createArgsFromquizzes']


class UserArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""


class quizzesArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    user: Union[bool, 'UserArgsFromquizzes']


class quiz_resultArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    user: Union[bool, 'UserArgsFromquizzes']


class user_progressArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    user: Union[bool, 'UserArgsFromquizzes']


class bookmark_quizArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    user: Union[bool, 'UserArgsFromquizzes']
    messages: Union[bool, 'FindManyMessageArgsFromquizzes']


class DebateSessionArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    session: Union[bool, 'DebateSessionArgsFromquizzes']


class MessageArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    interactions: Union[bool, 'FindManyInteractionArgsFromquizzes']
    user: Union[bool, 'UserArgsFromquizzes']


class companion_createArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromquizzes(TypedDict, total=False):
    """Relational arguments for quizzes"""
    companion: Union[bool, 'companion_createArgsFromquizzes']


class InteractionArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromquizzes(TypedDict, total=False):
    """Arguments for quizzes"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyquizzesArgs = FindManyquizzesArgsFromquizzes
FindFirstquizzesArgs = FindManyquizzesArgsFromquizzes


class quizzesWhereInput(TypedDict, total=False):
    """quizzes arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    quizId: Union[_str, 'types.StringFilter']
    grade: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    question: Union[_str, 'types.StringFilter']
    options: Union['fields.Json', 'types.JsonFilter']
    correct_answer: Union[_str, 'types.StringFilter']
    explanation: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['quizzesWhereInput', List['quizzesWhereInput']]
    # but this causes mypy to hang :/
    AND: List['quizzesWhereInput']
    OR: List['quizzesWhereInput']
    NOT: List['quizzesWhereInput']



# aggregate quizzes types


class quizzesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """quizzes arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    quizId: Union[_str, 'types.StringWithAggregatesFilter']
    grade: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    options: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    correct_answer: Union[_str, 'types.StringWithAggregatesFilter']
    explanation: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['quizzesScalarWhereWithAggregatesInput']
    OR: List['quizzesScalarWhereWithAggregatesInput']
    NOT: List['quizzesScalarWhereWithAggregatesInput']



class quizzesGroupByOutput(TypedDict, total=False):
    id: _int
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'quizzesSumAggregateOutput'
    _avg: 'quizzesAvgAggregateOutput'
    _min: 'quizzesMinAggregateOutput'
    _max: 'quizzesMaxAggregateOutput'
    _count: 'quizzesCountAggregateOutput'


class quizzesAvgAggregateOutput(TypedDict, total=False):
    """quizzes output for aggregating averages"""
    id: float


class quizzesSumAggregateOutput(TypedDict, total=False):
    """quizzes output for aggregating sums"""
    id: _int


class quizzesScalarAggregateOutput(TypedDict, total=False):
    """quizzes output including scalar fields"""
    id: _int
    title: _str
    quizId: _str
    grade: _str
    level: _str
    question: _str
    options: 'fields.Json'
    correct_answer: _str
    explanation: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


quizzesMinAggregateOutput = quizzesScalarAggregateOutput
quizzesMaxAggregateOutput = quizzesScalarAggregateOutput


class quizzesMaxAggregateInput(TypedDict, total=False):
    """quizzes input for aggregating by max"""
    id: bool
    title: bool
    quizId: bool
    grade: bool
    level: bool
    question: bool
    options: bool
    correct_answer: bool
    explanation: bool
    created_at: bool
    updated_at: bool


class quizzesMinAggregateInput(TypedDict, total=False):
    """quizzes input for aggregating by min"""
    id: bool
    title: bool
    quizId: bool
    grade: bool
    level: bool
    question: bool
    options: bool
    correct_answer: bool
    explanation: bool
    created_at: bool
    updated_at: bool


class quizzesNumberAggregateInput(TypedDict, total=False):
    """quizzes input for aggregating numbers"""
    id: bool


quizzesAvgAggregateInput = quizzesNumberAggregateInput
quizzesSumAggregateInput = quizzesNumberAggregateInput


quizzesCountAggregateInput = TypedDict(
    'quizzesCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'quizId': bool,
        'grade': bool,
        'level': bool,
        'question': bool,
        'options': bool,
        'correct_answer': bool,
        'explanation': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

quizzesCountAggregateOutput = TypedDict(
    'quizzesCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'quizId': int,
        'grade': int,
        'level': int,
        'question': int,
        'options': int,
        'correct_answer': int,
        'explanation': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


quizzesKeys = Literal[
    'id',
    'title',
    'quizId',
    'grade',
    'level',
    'question',
    'options',
    'correct_answer',
    'explanation',
    'created_at',
    'updated_at',
]
quizzesScalarFieldKeys = Literal[
    'id',
    'title',
    'quizId',
    'grade',
    'level',
    'question',
    'options',
    'correct_answer',
    'explanation',
    'created_at',
    'updated_at',
]
quizzesScalarFieldKeysT = TypeVar('quizzesScalarFieldKeysT', bound=quizzesScalarFieldKeys)

quizzesRelationalFieldKeys = _NoneType

# quiz_result types

class quiz_resultOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the quiz_result create method"""
    id: _str
    userId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'


class quiz_resultCreateInput(quiz_resultOptionalCreateInput):
    """Required arguments to the quiz_result create method"""
    correct_answer: _int
    Wrong_Answer: _int
    Total_question: _int
    level: _str
    Total_Marks: _int
    score: _int
    percentage: _int
    quizId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class quiz_resultOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the quiz_result create method, without relations"""
    id: _str
    userId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quiz_resultCreateWithoutRelationsInput(quiz_resultOptionalCreateWithoutRelationsInput):
    """Required arguments to the quiz_result create method, without relations"""
    correct_answer: _int
    Wrong_Answer: _int
    Total_question: _int
    level: _str
    Total_Marks: _int
    score: _int
    percentage: _int
    quizId: _str

class quiz_resultConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'quiz_resultCreateWithoutRelationsInput'
    where: 'quiz_resultWhereUniqueInput'

class quiz_resultCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'quiz_resultCreateWithoutRelationsInput'
    connect: 'quiz_resultWhereUniqueInput'
    connect_or_create: 'quiz_resultConnectOrCreateWithoutRelationsInput'


class quiz_resultCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['quiz_resultCreateWithoutRelationsInput', List['quiz_resultCreateWithoutRelationsInput']]
    connect: Union['quiz_resultWhereUniqueInput', List['quiz_resultWhereUniqueInput']]
    connect_or_create: Union['quiz_resultConnectOrCreateWithoutRelationsInput', List['quiz_resultConnectOrCreateWithoutRelationsInput']]

_quiz_resultWhereUnique_id_Input = TypedDict(
    '_quiz_resultWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

quiz_resultWhereUniqueInput = _quiz_resultWhereUnique_id_Input


class quiz_resultUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    correct_answer: Union[AtomicIntInput, _int]
    Wrong_Answer: Union[AtomicIntInput, _int]
    Total_question: Union[AtomicIntInput, _int]
    level: _str
    Total_Marks: Union[AtomicIntInput, _int]
    score: Union[AtomicIntInput, _int]
    percentage: Union[AtomicIntInput, _int]
    quizId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class quiz_resultUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    correct_answer: Union[AtomicIntInput, _int]
    Wrong_Answer: Union[AtomicIntInput, _int]
    Total_question: Union[AtomicIntInput, _int]
    level: _str
    Total_Marks: Union[AtomicIntInput, _int]
    score: Union[AtomicIntInput, _int]
    percentage: Union[AtomicIntInput, _int]
    quizId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class quiz_resultUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['quiz_resultCreateWithoutRelationsInput']
    connect: List['quiz_resultWhereUniqueInput']
    connect_or_create: List['quiz_resultConnectOrCreateWithoutRelationsInput']
    set: List['quiz_resultWhereUniqueInput']
    disconnect: List['quiz_resultWhereUniqueInput']
    delete: List['quiz_resultWhereUniqueInput']

    # TODO
    # update: List['quiz_resultUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['quiz_resultUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['quiz_resultScalarWhereInput']
    # upsert: List['quiz_resultUpserteWithWhereUniqueWithoutRelationsInput']


class quiz_resultUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'quiz_resultCreateWithoutRelationsInput'
    connect: 'quiz_resultWhereUniqueInput'
    connect_or_create: 'quiz_resultConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'quiz_resultUpdateInput'
    # upsert: 'quiz_resultUpsertWithoutRelationsInput'


class quiz_resultUpsertInput(TypedDict):
    create: 'quiz_resultCreateInput'
    update: 'quiz_resultUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_quiz_result_id_OrderByInput = TypedDict(
    '_quiz_result_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_quiz_result_userId_OrderByInput = TypedDict(
    '_quiz_result_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_quiz_result_correct_answer_OrderByInput = TypedDict(
    '_quiz_result_correct_answer_OrderByInput',
    {
        'correct_answer': 'SortOrder',
    },
    total=True
)

_quiz_result_Wrong_Answer_OrderByInput = TypedDict(
    '_quiz_result_Wrong_Answer_OrderByInput',
    {
        'Wrong_Answer': 'SortOrder',
    },
    total=True
)

_quiz_result_Total_question_OrderByInput = TypedDict(
    '_quiz_result_Total_question_OrderByInput',
    {
        'Total_question': 'SortOrder',
    },
    total=True
)

_quiz_result_level_OrderByInput = TypedDict(
    '_quiz_result_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_quiz_result_Total_Marks_OrderByInput = TypedDict(
    '_quiz_result_Total_Marks_OrderByInput',
    {
        'Total_Marks': 'SortOrder',
    },
    total=True
)

_quiz_result_score_OrderByInput = TypedDict(
    '_quiz_result_score_OrderByInput',
    {
        'score': 'SortOrder',
    },
    total=True
)

_quiz_result_percentage_OrderByInput = TypedDict(
    '_quiz_result_percentage_OrderByInput',
    {
        'percentage': 'SortOrder',
    },
    total=True
)

_quiz_result_quizId_OrderByInput = TypedDict(
    '_quiz_result_quizId_OrderByInput',
    {
        'quizId': 'SortOrder',
    },
    total=True
)

_quiz_result_created_at_OrderByInput = TypedDict(
    '_quiz_result_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_quiz_result_updated_at_OrderByInput = TypedDict(
    '_quiz_result_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_quiz_result_RelevanceInner = TypedDict(
    '_quiz_result_RelevanceInner',
    {
        'fields': 'List[quiz_resultScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_quiz_result_RelevanceOrderByInput = TypedDict(
    '_quiz_result_RelevanceOrderByInput',
    {
        '_relevance': '_quiz_result_RelevanceInner',
    },
    total=True
)

quiz_resultOrderByInput = Union[
    '_quiz_result_id_OrderByInput',
    '_quiz_result_userId_OrderByInput',
    '_quiz_result_correct_answer_OrderByInput',
    '_quiz_result_Wrong_Answer_OrderByInput',
    '_quiz_result_Total_question_OrderByInput',
    '_quiz_result_level_OrderByInput',
    '_quiz_result_Total_Marks_OrderByInput',
    '_quiz_result_score_OrderByInput',
    '_quiz_result_percentage_OrderByInput',
    '_quiz_result_quizId_OrderByInput',
    '_quiz_result_created_at_OrderByInput',
    '_quiz_result_updated_at_OrderByInput',
    '_quiz_result_RelevanceOrderByInput',
]



# recursive quiz_result types
# TODO: cleanup these types



quiz_resultRelationFilter = TypedDict(
    'quiz_resultRelationFilter',
    {
        'is': 'quiz_resultWhereInput',
        'is_not': 'quiz_resultWhereInput',
    },
    total=False,
)


class quiz_resultListRelationFilter(TypedDict, total=False):
    some: 'quiz_resultWhereInput'
    none: 'quiz_resultWhereInput'
    every: 'quiz_resultWhereInput'


class quiz_resultInclude(TypedDict, total=False):
    """quiz_result relational arguments"""
    user: Union[bool, 'UserArgsFromquiz_result']


class UserIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromquiz_result']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromquiz_result']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromquiz_result']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromquiz_result']
    companionData: Union[bool, 'FindManycompanion_createArgsFromquiz_result']


class UserArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""


class quizzesArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    user: Union[bool, 'UserArgsFromquiz_result']


class quiz_resultArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    user: Union[bool, 'UserArgsFromquiz_result']


class user_progressArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    user: Union[bool, 'UserArgsFromquiz_result']


class bookmark_quizArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    user: Union[bool, 'UserArgsFromquiz_result']
    messages: Union[bool, 'FindManyMessageArgsFromquiz_result']


class DebateSessionArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    session: Union[bool, 'DebateSessionArgsFromquiz_result']


class MessageArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    interactions: Union[bool, 'FindManyInteractionArgsFromquiz_result']
    user: Union[bool, 'UserArgsFromquiz_result']


class companion_createArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromquiz_result(TypedDict, total=False):
    """Relational arguments for quiz_result"""
    companion: Union[bool, 'companion_createArgsFromquiz_result']


class InteractionArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromquiz_result(TypedDict, total=False):
    """Arguments for quiz_result"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyquiz_resultArgs = FindManyquiz_resultArgsFromquiz_result
FindFirstquiz_resultArgs = FindManyquiz_resultArgsFromquiz_result


class quiz_resultWhereInput(TypedDict, total=False):
    """quiz_result arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    correct_answer: Union[_int, 'types.IntFilter']
    Wrong_Answer: Union[_int, 'types.IntFilter']
    Total_question: Union[_int, 'types.IntFilter']
    level: Union[_str, 'types.StringFilter']
    Total_Marks: Union[_int, 'types.IntFilter']
    score: Union[_int, 'types.IntFilter']
    percentage: Union[_int, 'types.IntFilter']
    quizId: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['quiz_resultWhereInput', List['quiz_resultWhereInput']]
    # but this causes mypy to hang :/
    AND: List['quiz_resultWhereInput']
    OR: List['quiz_resultWhereInput']
    NOT: List['quiz_resultWhereInput']



# aggregate quiz_result types


class quiz_resultScalarWhereWithAggregatesInput(TypedDict, total=False):
    """quiz_result arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    correct_answer: Union[_int, 'types.IntWithAggregatesFilter']
    Wrong_Answer: Union[_int, 'types.IntWithAggregatesFilter']
    Total_question: Union[_int, 'types.IntWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    Total_Marks: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    percentage: Union[_int, 'types.IntWithAggregatesFilter']
    quizId: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['quiz_resultScalarWhereWithAggregatesInput']
    OR: List['quiz_resultScalarWhereWithAggregatesInput']
    NOT: List['quiz_resultScalarWhereWithAggregatesInput']



class quiz_resultGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    correct_answer: _int
    Wrong_Answer: _int
    Total_question: _int
    level: _str
    Total_Marks: _int
    score: _int
    percentage: _int
    quizId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'quiz_resultSumAggregateOutput'
    _avg: 'quiz_resultAvgAggregateOutput'
    _min: 'quiz_resultMinAggregateOutput'
    _max: 'quiz_resultMaxAggregateOutput'
    _count: 'quiz_resultCountAggregateOutput'


class quiz_resultAvgAggregateOutput(TypedDict, total=False):
    """quiz_result output for aggregating averages"""
    correct_answer: float
    Wrong_Answer: float
    Total_question: float
    Total_Marks: float
    score: float
    percentage: float


class quiz_resultSumAggregateOutput(TypedDict, total=False):
    """quiz_result output for aggregating sums"""
    correct_answer: _int
    Wrong_Answer: _int
    Total_question: _int
    Total_Marks: _int
    score: _int
    percentage: _int


class quiz_resultScalarAggregateOutput(TypedDict, total=False):
    """quiz_result output including scalar fields"""
    id: _str
    userId: _str
    correct_answer: _int
    Wrong_Answer: _int
    Total_question: _int
    level: _str
    Total_Marks: _int
    score: _int
    percentage: _int
    quizId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


quiz_resultMinAggregateOutput = quiz_resultScalarAggregateOutput
quiz_resultMaxAggregateOutput = quiz_resultScalarAggregateOutput


class quiz_resultMaxAggregateInput(TypedDict, total=False):
    """quiz_result input for aggregating by max"""
    id: bool
    userId: bool
    correct_answer: bool
    Wrong_Answer: bool
    Total_question: bool
    level: bool
    Total_Marks: bool
    score: bool
    percentage: bool
    quizId: bool
    created_at: bool
    updated_at: bool


class quiz_resultMinAggregateInput(TypedDict, total=False):
    """quiz_result input for aggregating by min"""
    id: bool
    userId: bool
    correct_answer: bool
    Wrong_Answer: bool
    Total_question: bool
    level: bool
    Total_Marks: bool
    score: bool
    percentage: bool
    quizId: bool
    created_at: bool
    updated_at: bool


class quiz_resultNumberAggregateInput(TypedDict, total=False):
    """quiz_result input for aggregating numbers"""
    correct_answer: bool
    Wrong_Answer: bool
    Total_question: bool
    Total_Marks: bool
    score: bool
    percentage: bool


quiz_resultAvgAggregateInput = quiz_resultNumberAggregateInput
quiz_resultSumAggregateInput = quiz_resultNumberAggregateInput


quiz_resultCountAggregateInput = TypedDict(
    'quiz_resultCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'correct_answer': bool,
        'Wrong_Answer': bool,
        'Total_question': bool,
        'level': bool,
        'Total_Marks': bool,
        'score': bool,
        'percentage': bool,
        'quizId': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

quiz_resultCountAggregateOutput = TypedDict(
    'quiz_resultCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'correct_answer': int,
        'Wrong_Answer': int,
        'Total_question': int,
        'level': int,
        'Total_Marks': int,
        'score': int,
        'percentage': int,
        'quizId': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


quiz_resultKeys = Literal[
    'id',
    'userId',
    'correct_answer',
    'Wrong_Answer',
    'Total_question',
    'level',
    'Total_Marks',
    'score',
    'percentage',
    'quizId',
    'created_at',
    'updated_at',
    'user',
]
quiz_resultScalarFieldKeys = Literal[
    'id',
    'userId',
    'correct_answer',
    'Wrong_Answer',
    'Total_question',
    'level',
    'Total_Marks',
    'score',
    'percentage',
    'quizId',
    'created_at',
    'updated_at',
]
quiz_resultScalarFieldKeysT = TypeVar('quiz_resultScalarFieldKeysT', bound=quiz_resultScalarFieldKeys)

quiz_resultRelationalFieldKeys = Literal[
        'user',
    ]

# user_progress types

class user_progressOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the user_progress create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class user_progressCreateInput(user_progressOptionalCreateInput):
    """Required arguments to the user_progress create method"""
    grade: _str
    Exp: _int
    Level: _int
    Badges: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class user_progressOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the user_progress create method, without relations"""
    id: _str
    userId: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class user_progressCreateWithoutRelationsInput(user_progressOptionalCreateWithoutRelationsInput):
    """Required arguments to the user_progress create method, without relations"""
    grade: _str
    Exp: _int
    Level: _int
    Badges: 'fields.Json'

class user_progressConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'user_progressCreateWithoutRelationsInput'
    where: 'user_progressWhereUniqueInput'

class user_progressCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'user_progressCreateWithoutRelationsInput'
    connect: 'user_progressWhereUniqueInput'
    connect_or_create: 'user_progressConnectOrCreateWithoutRelationsInput'


class user_progressCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['user_progressCreateWithoutRelationsInput', List['user_progressCreateWithoutRelationsInput']]
    connect: Union['user_progressWhereUniqueInput', List['user_progressWhereUniqueInput']]
    connect_or_create: Union['user_progressConnectOrCreateWithoutRelationsInput', List['user_progressConnectOrCreateWithoutRelationsInput']]

_user_progressWhereUnique_id_Input = TypedDict(
    '_user_progressWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

user_progressWhereUniqueInput = _user_progressWhereUnique_id_Input


class user_progressUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    grade: _str
    Exp: Union[AtomicIntInput, _int]
    Level: Union[AtomicIntInput, _int]
    Badges: 'fields.Json'
    user: 'UserUpdateOneWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class user_progressUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    grade: _str
    Exp: Union[AtomicIntInput, _int]
    Level: Union[AtomicIntInput, _int]
    Badges: 'fields.Json'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class user_progressUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['user_progressCreateWithoutRelationsInput']
    connect: List['user_progressWhereUniqueInput']
    connect_or_create: List['user_progressConnectOrCreateWithoutRelationsInput']
    set: List['user_progressWhereUniqueInput']
    disconnect: List['user_progressWhereUniqueInput']
    delete: List['user_progressWhereUniqueInput']

    # TODO
    # update: List['user_progressUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['user_progressUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['user_progressScalarWhereInput']
    # upsert: List['user_progressUpserteWithWhereUniqueWithoutRelationsInput']


class user_progressUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'user_progressCreateWithoutRelationsInput'
    connect: 'user_progressWhereUniqueInput'
    connect_or_create: 'user_progressConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'user_progressUpdateInput'
    # upsert: 'user_progressUpsertWithoutRelationsInput'


class user_progressUpsertInput(TypedDict):
    create: 'user_progressCreateInput'
    update: 'user_progressUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_user_progress_id_OrderByInput = TypedDict(
    '_user_progress_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_user_progress_userId_OrderByInput = TypedDict(
    '_user_progress_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_user_progress_grade_OrderByInput = TypedDict(
    '_user_progress_grade_OrderByInput',
    {
        'grade': 'SortOrder',
    },
    total=True
)

_user_progress_Exp_OrderByInput = TypedDict(
    '_user_progress_Exp_OrderByInput',
    {
        'Exp': 'SortOrder',
    },
    total=True
)

_user_progress_Level_OrderByInput = TypedDict(
    '_user_progress_Level_OrderByInput',
    {
        'Level': 'SortOrder',
    },
    total=True
)

_user_progress_Badges_OrderByInput = TypedDict(
    '_user_progress_Badges_OrderByInput',
    {
        'Badges': 'SortOrder',
    },
    total=True
)

_user_progress_created_at_OrderByInput = TypedDict(
    '_user_progress_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_user_progress_updated_at_OrderByInput = TypedDict(
    '_user_progress_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_user_progress_RelevanceInner = TypedDict(
    '_user_progress_RelevanceInner',
    {
        'fields': 'List[user_progressScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_user_progress_RelevanceOrderByInput = TypedDict(
    '_user_progress_RelevanceOrderByInput',
    {
        '_relevance': '_user_progress_RelevanceInner',
    },
    total=True
)

user_progressOrderByInput = Union[
    '_user_progress_id_OrderByInput',
    '_user_progress_userId_OrderByInput',
    '_user_progress_grade_OrderByInput',
    '_user_progress_Exp_OrderByInput',
    '_user_progress_Level_OrderByInput',
    '_user_progress_Badges_OrderByInput',
    '_user_progress_created_at_OrderByInput',
    '_user_progress_updated_at_OrderByInput',
    '_user_progress_RelevanceOrderByInput',
]



# recursive user_progress types
# TODO: cleanup these types



user_progressRelationFilter = TypedDict(
    'user_progressRelationFilter',
    {
        'is': 'user_progressWhereInput',
        'is_not': 'user_progressWhereInput',
    },
    total=False,
)


class user_progressListRelationFilter(TypedDict, total=False):
    some: 'user_progressWhereInput'
    none: 'user_progressWhereInput'
    every: 'user_progressWhereInput'


class user_progressInclude(TypedDict, total=False):
    """user_progress relational arguments"""
    user: Union[bool, 'UserArgsFromuser_progress']


class UserIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromuser_progress']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromuser_progress']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromuser_progress']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromuser_progress']
    companionData: Union[bool, 'FindManycompanion_createArgsFromuser_progress']


class UserArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""


class quizzesArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    user: Union[bool, 'UserArgsFromuser_progress']


class quiz_resultArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    user: Union[bool, 'UserArgsFromuser_progress']


class user_progressArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    user: Union[bool, 'UserArgsFromuser_progress']


class bookmark_quizArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    user: Union[bool, 'UserArgsFromuser_progress']
    messages: Union[bool, 'FindManyMessageArgsFromuser_progress']


class DebateSessionArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    session: Union[bool, 'DebateSessionArgsFromuser_progress']


class MessageArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    interactions: Union[bool, 'FindManyInteractionArgsFromuser_progress']
    user: Union[bool, 'UserArgsFromuser_progress']


class companion_createArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromuser_progress(TypedDict, total=False):
    """Relational arguments for user_progress"""
    companion: Union[bool, 'companion_createArgsFromuser_progress']


class InteractionArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromuser_progress(TypedDict, total=False):
    """Arguments for user_progress"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyuser_progressArgs = FindManyuser_progressArgsFromuser_progress
FindFirstuser_progressArgs = FindManyuser_progressArgsFromuser_progress


class user_progressWhereInput(TypedDict, total=False):
    """user_progress arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    grade: Union[_str, 'types.StringFilter']
    Exp: Union[_int, 'types.IntFilter']
    Level: Union[_int, 'types.IntFilter']
    Badges: Union['fields.Json', 'types.JsonFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['user_progressWhereInput', List['user_progressWhereInput']]
    # but this causes mypy to hang :/
    AND: List['user_progressWhereInput']
    OR: List['user_progressWhereInput']
    NOT: List['user_progressWhereInput']



# aggregate user_progress types


class user_progressScalarWhereWithAggregatesInput(TypedDict, total=False):
    """user_progress arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    grade: Union[_str, 'types.StringWithAggregatesFilter']
    Exp: Union[_int, 'types.IntWithAggregatesFilter']
    Level: Union[_int, 'types.IntWithAggregatesFilter']
    Badges: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['user_progressScalarWhereWithAggregatesInput']
    OR: List['user_progressScalarWhereWithAggregatesInput']
    NOT: List['user_progressScalarWhereWithAggregatesInput']



class user_progressGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    grade: _str
    Exp: _int
    Level: _int
    Badges: 'fields.Json'
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'user_progressSumAggregateOutput'
    _avg: 'user_progressAvgAggregateOutput'
    _min: 'user_progressMinAggregateOutput'
    _max: 'user_progressMaxAggregateOutput'
    _count: 'user_progressCountAggregateOutput'


class user_progressAvgAggregateOutput(TypedDict, total=False):
    """user_progress output for aggregating averages"""
    Exp: float
    Level: float


class user_progressSumAggregateOutput(TypedDict, total=False):
    """user_progress output for aggregating sums"""
    Exp: _int
    Level: _int


class user_progressScalarAggregateOutput(TypedDict, total=False):
    """user_progress output including scalar fields"""
    id: _str
    userId: _str
    grade: _str
    Exp: _int
    Level: _int
    Badges: 'fields.Json'
    created_at: datetime.datetime
    updated_at: datetime.datetime


user_progressMinAggregateOutput = user_progressScalarAggregateOutput
user_progressMaxAggregateOutput = user_progressScalarAggregateOutput


class user_progressMaxAggregateInput(TypedDict, total=False):
    """user_progress input for aggregating by max"""
    id: bool
    userId: bool
    grade: bool
    Exp: bool
    Level: bool
    Badges: bool
    created_at: bool
    updated_at: bool


class user_progressMinAggregateInput(TypedDict, total=False):
    """user_progress input for aggregating by min"""
    id: bool
    userId: bool
    grade: bool
    Exp: bool
    Level: bool
    Badges: bool
    created_at: bool
    updated_at: bool


class user_progressNumberAggregateInput(TypedDict, total=False):
    """user_progress input for aggregating numbers"""
    Exp: bool
    Level: bool


user_progressAvgAggregateInput = user_progressNumberAggregateInput
user_progressSumAggregateInput = user_progressNumberAggregateInput


user_progressCountAggregateInput = TypedDict(
    'user_progressCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'grade': bool,
        'Exp': bool,
        'Level': bool,
        'Badges': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

user_progressCountAggregateOutput = TypedDict(
    'user_progressCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'grade': int,
        'Exp': int,
        'Level': int,
        'Badges': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


user_progressKeys = Literal[
    'id',
    'userId',
    'grade',
    'Exp',
    'Level',
    'Badges',
    'user',
    'created_at',
    'updated_at',
]
user_progressScalarFieldKeys = Literal[
    'id',
    'userId',
    'grade',
    'Exp',
    'Level',
    'Badges',
    'created_at',
    'updated_at',
]
user_progressScalarFieldKeysT = TypeVar('user_progressScalarFieldKeysT', bound=user_progressScalarFieldKeys)

user_progressRelationalFieldKeys = Literal[
        'user',
    ]

# bookmark_quiz types

class bookmark_quizOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the bookmark_quiz create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'


class bookmark_quizCreateInput(bookmark_quizOptionalCreateInput):
    """Required arguments to the bookmark_quiz create method"""
    quizId: _str
    level: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class bookmark_quizOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the bookmark_quiz create method, without relations"""
    id: _str
    userId: _str


class bookmark_quizCreateWithoutRelationsInput(bookmark_quizOptionalCreateWithoutRelationsInput):
    """Required arguments to the bookmark_quiz create method, without relations"""
    quizId: _str
    level: _str

class bookmark_quizConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'bookmark_quizCreateWithoutRelationsInput'
    where: 'bookmark_quizWhereUniqueInput'

class bookmark_quizCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'bookmark_quizCreateWithoutRelationsInput'
    connect: 'bookmark_quizWhereUniqueInput'
    connect_or_create: 'bookmark_quizConnectOrCreateWithoutRelationsInput'


class bookmark_quizCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['bookmark_quizCreateWithoutRelationsInput', List['bookmark_quizCreateWithoutRelationsInput']]
    connect: Union['bookmark_quizWhereUniqueInput', List['bookmark_quizWhereUniqueInput']]
    connect_or_create: Union['bookmark_quizConnectOrCreateWithoutRelationsInput', List['bookmark_quizConnectOrCreateWithoutRelationsInput']]

_bookmark_quizWhereUnique_id_Input = TypedDict(
    '_bookmark_quizWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

bookmark_quizWhereUniqueInput = _bookmark_quizWhereUnique_id_Input


class bookmark_quizUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    quizId: _str
    level: _str
    user: 'UserUpdateOneWithoutRelationsInput'


class bookmark_quizUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    quizId: _str
    level: _str


class bookmark_quizUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['bookmark_quizCreateWithoutRelationsInput']
    connect: List['bookmark_quizWhereUniqueInput']
    connect_or_create: List['bookmark_quizConnectOrCreateWithoutRelationsInput']
    set: List['bookmark_quizWhereUniqueInput']
    disconnect: List['bookmark_quizWhereUniqueInput']
    delete: List['bookmark_quizWhereUniqueInput']

    # TODO
    # update: List['bookmark_quizUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['bookmark_quizUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['bookmark_quizScalarWhereInput']
    # upsert: List['bookmark_quizUpserteWithWhereUniqueWithoutRelationsInput']


class bookmark_quizUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'bookmark_quizCreateWithoutRelationsInput'
    connect: 'bookmark_quizWhereUniqueInput'
    connect_or_create: 'bookmark_quizConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'bookmark_quizUpdateInput'
    # upsert: 'bookmark_quizUpsertWithoutRelationsInput'


class bookmark_quizUpsertInput(TypedDict):
    create: 'bookmark_quizCreateInput'
    update: 'bookmark_quizUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_bookmark_quiz_id_OrderByInput = TypedDict(
    '_bookmark_quiz_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_bookmark_quiz_userId_OrderByInput = TypedDict(
    '_bookmark_quiz_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_bookmark_quiz_quizId_OrderByInput = TypedDict(
    '_bookmark_quiz_quizId_OrderByInput',
    {
        'quizId': 'SortOrder',
    },
    total=True
)

_bookmark_quiz_level_OrderByInput = TypedDict(
    '_bookmark_quiz_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_bookmark_quiz_RelevanceInner = TypedDict(
    '_bookmark_quiz_RelevanceInner',
    {
        'fields': 'List[bookmark_quizScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_bookmark_quiz_RelevanceOrderByInput = TypedDict(
    '_bookmark_quiz_RelevanceOrderByInput',
    {
        '_relevance': '_bookmark_quiz_RelevanceInner',
    },
    total=True
)

bookmark_quizOrderByInput = Union[
    '_bookmark_quiz_id_OrderByInput',
    '_bookmark_quiz_userId_OrderByInput',
    '_bookmark_quiz_quizId_OrderByInput',
    '_bookmark_quiz_level_OrderByInput',
    '_bookmark_quiz_RelevanceOrderByInput',
]



# recursive bookmark_quiz types
# TODO: cleanup these types



bookmark_quizRelationFilter = TypedDict(
    'bookmark_quizRelationFilter',
    {
        'is': 'bookmark_quizWhereInput',
        'is_not': 'bookmark_quizWhereInput',
    },
    total=False,
)


class bookmark_quizListRelationFilter(TypedDict, total=False):
    some: 'bookmark_quizWhereInput'
    none: 'bookmark_quizWhereInput'
    every: 'bookmark_quizWhereInput'


class bookmark_quizInclude(TypedDict, total=False):
    """bookmark_quiz relational arguments"""
    user: Union[bool, 'UserArgsFrombookmark_quiz']


class UserIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFrombookmark_quiz']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFrombookmark_quiz']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFrombookmark_quiz']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFrombookmark_quiz']
    companionData: Union[bool, 'FindManycompanion_createArgsFrombookmark_quiz']


class UserArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""


class quizzesArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    user: Union[bool, 'UserArgsFrombookmark_quiz']


class quiz_resultArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    user: Union[bool, 'UserArgsFrombookmark_quiz']


class user_progressArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    user: Union[bool, 'UserArgsFrombookmark_quiz']


class bookmark_quizArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    user: Union[bool, 'UserArgsFrombookmark_quiz']
    messages: Union[bool, 'FindManyMessageArgsFrombookmark_quiz']


class DebateSessionArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    session: Union[bool, 'DebateSessionArgsFrombookmark_quiz']


class MessageArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    interactions: Union[bool, 'FindManyInteractionArgsFrombookmark_quiz']
    user: Union[bool, 'UserArgsFrombookmark_quiz']


class companion_createArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFrombookmark_quiz(TypedDict, total=False):
    """Relational arguments for bookmark_quiz"""
    companion: Union[bool, 'companion_createArgsFrombookmark_quiz']


class InteractionArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFrombookmark_quiz(TypedDict, total=False):
    """Arguments for bookmark_quiz"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManybookmark_quizArgs = FindManybookmark_quizArgsFrombookmark_quiz
FindFirstbookmark_quizArgs = FindManybookmark_quizArgsFrombookmark_quiz


class bookmark_quizWhereInput(TypedDict, total=False):
    """bookmark_quiz arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    quizId: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['bookmark_quizWhereInput', List['bookmark_quizWhereInput']]
    # but this causes mypy to hang :/
    AND: List['bookmark_quizWhereInput']
    OR: List['bookmark_quizWhereInput']
    NOT: List['bookmark_quizWhereInput']



# aggregate bookmark_quiz types


class bookmark_quizScalarWhereWithAggregatesInput(TypedDict, total=False):
    """bookmark_quiz arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    quizId: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['bookmark_quizScalarWhereWithAggregatesInput']
    OR: List['bookmark_quizScalarWhereWithAggregatesInput']
    NOT: List['bookmark_quizScalarWhereWithAggregatesInput']



class bookmark_quizGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    quizId: _str
    level: _str
    _sum: 'bookmark_quizSumAggregateOutput'
    _avg: 'bookmark_quizAvgAggregateOutput'
    _min: 'bookmark_quizMinAggregateOutput'
    _max: 'bookmark_quizMaxAggregateOutput'
    _count: 'bookmark_quizCountAggregateOutput'


class bookmark_quizAvgAggregateOutput(TypedDict, total=False):
    """bookmark_quiz output for aggregating averages"""


class bookmark_quizSumAggregateOutput(TypedDict, total=False):
    """bookmark_quiz output for aggregating sums"""


class bookmark_quizScalarAggregateOutput(TypedDict, total=False):
    """bookmark_quiz output including scalar fields"""
    id: _str
    userId: _str
    quizId: _str
    level: _str


bookmark_quizMinAggregateOutput = bookmark_quizScalarAggregateOutput
bookmark_quizMaxAggregateOutput = bookmark_quizScalarAggregateOutput


class bookmark_quizMaxAggregateInput(TypedDict, total=False):
    """bookmark_quiz input for aggregating by max"""
    id: bool
    userId: bool
    quizId: bool
    level: bool


class bookmark_quizMinAggregateInput(TypedDict, total=False):
    """bookmark_quiz input for aggregating by min"""
    id: bool
    userId: bool
    quizId: bool
    level: bool


class bookmark_quizNumberAggregateInput(TypedDict, total=False):
    """bookmark_quiz input for aggregating numbers"""


bookmark_quizAvgAggregateInput = bookmark_quizNumberAggregateInput
bookmark_quizSumAggregateInput = bookmark_quizNumberAggregateInput


bookmark_quizCountAggregateInput = TypedDict(
    'bookmark_quizCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'quizId': bool,
        'level': bool,
        '_all': bool,
    },
    total=False,
)

bookmark_quizCountAggregateOutput = TypedDict(
    'bookmark_quizCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'quizId': int,
        'level': int,
        '_all': int,
    },
    total=False,
)


bookmark_quizKeys = Literal[
    'id',
    'userId',
    'quizId',
    'level',
    'user',
]
bookmark_quizScalarFieldKeys = Literal[
    'id',
    'userId',
    'quizId',
    'level',
]
bookmark_quizScalarFieldKeysT = TypeVar('bookmark_quizScalarFieldKeysT', bound=bookmark_quizScalarFieldKeys)

bookmark_quizRelationalFieldKeys = Literal[
        'user',
    ]

# DebateSession types

class DebateSessionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the DebateSession create method"""
    id: _str
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    user: 'UserCreateNestedWithoutRelationsInput'
    userId: _str
    messages: 'MessageCreateManyNestedWithoutRelationsInput'
    winner: Optional[_str]
    feedback: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DebateSessionCreateInput(DebateSessionOptionalCreateInput):
    """Required arguments to the DebateSession create method"""
    topic: _str
    duration: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DebateSessionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the DebateSession create method, without relations"""
    id: _str
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    userId: _str
    winner: Optional[_str]
    feedback: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DebateSessionCreateWithoutRelationsInput(DebateSessionOptionalCreateWithoutRelationsInput):
    """Required arguments to the DebateSession create method, without relations"""
    topic: _str
    duration: _int

class DebateSessionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'DebateSessionCreateWithoutRelationsInput'
    where: 'DebateSessionWhereUniqueInput'

class DebateSessionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DebateSessionCreateWithoutRelationsInput'
    connect: 'DebateSessionWhereUniqueInput'
    connect_or_create: 'DebateSessionConnectOrCreateWithoutRelationsInput'


class DebateSessionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DebateSessionCreateWithoutRelationsInput', List['DebateSessionCreateWithoutRelationsInput']]
    connect: Union['DebateSessionWhereUniqueInput', List['DebateSessionWhereUniqueInput']]
    connect_or_create: Union['DebateSessionConnectOrCreateWithoutRelationsInput', List['DebateSessionConnectOrCreateWithoutRelationsInput']]

_DebateSessionWhereUnique_id_Input = TypedDict(
    '_DebateSessionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DebateSessionWhereUniqueInput = _DebateSessionWhereUnique_id_Input


class DebateSessionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    topic: _str
    duration: Union[AtomicIntInput, _int]
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    user: 'UserUpdateOneWithoutRelationsInput'
    messages: 'MessageUpdateManyWithoutRelationsInput'
    winner: Optional[_str]
    feedback: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DebateSessionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    topic: _str
    duration: Union[AtomicIntInput, _int]
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    winner: Optional[_str]
    feedback: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DebateSessionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DebateSessionCreateWithoutRelationsInput']
    connect: List['DebateSessionWhereUniqueInput']
    connect_or_create: List['DebateSessionConnectOrCreateWithoutRelationsInput']
    set: List['DebateSessionWhereUniqueInput']
    disconnect: List['DebateSessionWhereUniqueInput']
    delete: List['DebateSessionWhereUniqueInput']

    # TODO
    # update: List['DebateSessionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DebateSessionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DebateSessionScalarWhereInput']
    # upsert: List['DebateSessionUpserteWithWhereUniqueWithoutRelationsInput']


class DebateSessionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DebateSessionCreateWithoutRelationsInput'
    connect: 'DebateSessionWhereUniqueInput'
    connect_or_create: 'DebateSessionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DebateSessionUpdateInput'
    # upsert: 'DebateSessionUpsertWithoutRelationsInput'


class DebateSessionUpsertInput(TypedDict):
    create: 'DebateSessionCreateInput'
    update: 'DebateSessionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_DebateSession_id_OrderByInput = TypedDict(
    '_DebateSession_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_DebateSession_topic_OrderByInput = TypedDict(
    '_DebateSession_topic_OrderByInput',
    {
        'topic': 'SortOrder',
    },
    total=True
)

_DebateSession_duration_OrderByInput = TypedDict(
    '_DebateSession_duration_OrderByInput',
    {
        'duration': 'SortOrder',
    },
    total=True
)

_DebateSession_startTime_OrderByInput = TypedDict(
    '_DebateSession_startTime_OrderByInput',
    {
        'startTime': 'SortOrder',
    },
    total=True
)

_DebateSession_endTime_OrderByInput = TypedDict(
    '_DebateSession_endTime_OrderByInput',
    {
        'endTime': 'SortOrder',
    },
    total=True
)

_DebateSession_userId_OrderByInput = TypedDict(
    '_DebateSession_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_DebateSession_winner_OrderByInput = TypedDict(
    '_DebateSession_winner_OrderByInput',
    {
        'winner': 'SortOrder',
    },
    total=True
)

_DebateSession_feedback_OrderByInput = TypedDict(
    '_DebateSession_feedback_OrderByInput',
    {
        'feedback': 'SortOrder',
    },
    total=True
)

_DebateSession_createdAt_OrderByInput = TypedDict(
    '_DebateSession_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_DebateSession_updatedAt_OrderByInput = TypedDict(
    '_DebateSession_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_DebateSession_RelevanceInner = TypedDict(
    '_DebateSession_RelevanceInner',
    {
        'fields': 'List[DebateSessionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_DebateSession_RelevanceOrderByInput = TypedDict(
    '_DebateSession_RelevanceOrderByInput',
    {
        '_relevance': '_DebateSession_RelevanceInner',
    },
    total=True
)

DebateSessionOrderByInput = Union[
    '_DebateSession_id_OrderByInput',
    '_DebateSession_topic_OrderByInput',
    '_DebateSession_duration_OrderByInput',
    '_DebateSession_startTime_OrderByInput',
    '_DebateSession_endTime_OrderByInput',
    '_DebateSession_userId_OrderByInput',
    '_DebateSession_winner_OrderByInput',
    '_DebateSession_feedback_OrderByInput',
    '_DebateSession_createdAt_OrderByInput',
    '_DebateSession_updatedAt_OrderByInput',
    '_DebateSession_RelevanceOrderByInput',
]



# recursive DebateSession types
# TODO: cleanup these types



DebateSessionRelationFilter = TypedDict(
    'DebateSessionRelationFilter',
    {
        'is': 'DebateSessionWhereInput',
        'is_not': 'DebateSessionWhereInput',
    },
    total=False,
)


class DebateSessionListRelationFilter(TypedDict, total=False):
    some: 'DebateSessionWhereInput'
    none: 'DebateSessionWhereInput'
    every: 'DebateSessionWhereInput'


class DebateSessionInclude(TypedDict, total=False):
    """DebateSession relational arguments"""
    user: Union[bool, 'UserArgsFromDebateSession']
    messages: Union[bool, 'FindManyMessageArgsFromDebateSession']


class UserIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromDebateSession']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromDebateSession']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromDebateSession']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromDebateSession']
    companionData: Union[bool, 'FindManycompanion_createArgsFromDebateSession']


class UserArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""


class quizzesArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    user: Union[bool, 'UserArgsFromDebateSession']


class quiz_resultArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    user: Union[bool, 'UserArgsFromDebateSession']


class user_progressArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    user: Union[bool, 'UserArgsFromDebateSession']


class bookmark_quizArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    user: Union[bool, 'UserArgsFromDebateSession']
    messages: Union[bool, 'FindManyMessageArgsFromDebateSession']


class DebateSessionArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    session: Union[bool, 'DebateSessionArgsFromDebateSession']


class MessageArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    interactions: Union[bool, 'FindManyInteractionArgsFromDebateSession']
    user: Union[bool, 'UserArgsFromDebateSession']


class companion_createArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromDebateSession(TypedDict, total=False):
    """Relational arguments for DebateSession"""
    companion: Union[bool, 'companion_createArgsFromDebateSession']


class InteractionArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromDebateSession(TypedDict, total=False):
    """Arguments for DebateSession"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyDebateSessionArgs = FindManyDebateSessionArgsFromDebateSession
FindFirstDebateSessionArgs = FindManyDebateSessionArgsFromDebateSession


class DebateSessionWhereInput(TypedDict, total=False):
    """DebateSession arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    messages: 'MessageListRelationFilter'
    winner: Union[None, _str, 'types.StringFilter']
    feedback: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DebateSessionWhereInput', List['DebateSessionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['DebateSessionWhereInput']
    OR: List['DebateSessionWhereInput']
    NOT: List['DebateSessionWhereInput']



# aggregate DebateSession types


class DebateSessionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """DebateSession arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    winner: Union[_str, 'types.StringWithAggregatesFilter']
    feedback: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DebateSessionScalarWhereWithAggregatesInput']
    OR: List['DebateSessionScalarWhereWithAggregatesInput']
    NOT: List['DebateSessionScalarWhereWithAggregatesInput']



class DebateSessionGroupByOutput(TypedDict, total=False):
    id: _str
    topic: _str
    duration: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    userId: _str
    winner: _str
    feedback: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'DebateSessionSumAggregateOutput'
    _avg: 'DebateSessionAvgAggregateOutput'
    _min: 'DebateSessionMinAggregateOutput'
    _max: 'DebateSessionMaxAggregateOutput'
    _count: 'DebateSessionCountAggregateOutput'


class DebateSessionAvgAggregateOutput(TypedDict, total=False):
    """DebateSession output for aggregating averages"""
    duration: float


class DebateSessionSumAggregateOutput(TypedDict, total=False):
    """DebateSession output for aggregating sums"""
    duration: _int


class DebateSessionScalarAggregateOutput(TypedDict, total=False):
    """DebateSession output including scalar fields"""
    id: _str
    topic: _str
    duration: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    userId: _str
    winner: _str
    feedback: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


DebateSessionMinAggregateOutput = DebateSessionScalarAggregateOutput
DebateSessionMaxAggregateOutput = DebateSessionScalarAggregateOutput


class DebateSessionMaxAggregateInput(TypedDict, total=False):
    """DebateSession input for aggregating by max"""
    id: bool
    topic: bool
    duration: bool
    startTime: bool
    endTime: bool
    userId: bool
    winner: bool
    feedback: bool
    createdAt: bool
    updatedAt: bool


class DebateSessionMinAggregateInput(TypedDict, total=False):
    """DebateSession input for aggregating by min"""
    id: bool
    topic: bool
    duration: bool
    startTime: bool
    endTime: bool
    userId: bool
    winner: bool
    feedback: bool
    createdAt: bool
    updatedAt: bool


class DebateSessionNumberAggregateInput(TypedDict, total=False):
    """DebateSession input for aggregating numbers"""
    duration: bool


DebateSessionAvgAggregateInput = DebateSessionNumberAggregateInput
DebateSessionSumAggregateInput = DebateSessionNumberAggregateInput


DebateSessionCountAggregateInput = TypedDict(
    'DebateSessionCountAggregateInput',
    {
        'id': bool,
        'topic': bool,
        'duration': bool,
        'startTime': bool,
        'endTime': bool,
        'userId': bool,
        'winner': bool,
        'feedback': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

DebateSessionCountAggregateOutput = TypedDict(
    'DebateSessionCountAggregateOutput',
    {
        'id': int,
        'topic': int,
        'duration': int,
        'startTime': int,
        'endTime': int,
        'userId': int,
        'winner': int,
        'feedback': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


DebateSessionKeys = Literal[
    'id',
    'topic',
    'duration',
    'startTime',
    'endTime',
    'user',
    'userId',
    'messages',
    'winner',
    'feedback',
    'createdAt',
    'updatedAt',
]
DebateSessionScalarFieldKeys = Literal[
    'id',
    'topic',
    'duration',
    'startTime',
    'endTime',
    'userId',
    'winner',
    'feedback',
    'createdAt',
    'updatedAt',
]
DebateSessionScalarFieldKeysT = TypeVar('DebateSessionScalarFieldKeysT', bound=DebateSessionScalarFieldKeys)

DebateSessionRelationalFieldKeys = Literal[
        'user',
        'messages',
    ]

# Message types

class MessageOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Message create method"""
    id: _str
    session: 'DebateSessionCreateNestedWithoutRelationsInput'
    sessionId: _str
    createdAt: datetime.datetime


class MessageCreateInput(MessageOptionalCreateInput):
    """Required arguments to the Message create method"""
    role: _str
    content: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MessageOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Message create method, without relations"""
    id: _str
    sessionId: _str
    createdAt: datetime.datetime


class MessageCreateWithoutRelationsInput(MessageOptionalCreateWithoutRelationsInput):
    """Required arguments to the Message create method, without relations"""
    role: _str
    content: _str

class MessageConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MessageCreateWithoutRelationsInput'
    where: 'MessageWhereUniqueInput'

class MessageCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'


class MessageCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MessageCreateWithoutRelationsInput', List['MessageCreateWithoutRelationsInput']]
    connect: Union['MessageWhereUniqueInput', List['MessageWhereUniqueInput']]
    connect_or_create: Union['MessageConnectOrCreateWithoutRelationsInput', List['MessageConnectOrCreateWithoutRelationsInput']]

_MessageWhereUnique_id_Input = TypedDict(
    '_MessageWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

MessageWhereUniqueInput = _MessageWhereUnique_id_Input


class MessageUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    session: 'DebateSessionUpdateOneWithoutRelationsInput'
    role: _str
    content: _str
    createdAt: datetime.datetime


class MessageUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    role: _str
    content: _str
    createdAt: datetime.datetime


class MessageUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MessageCreateWithoutRelationsInput']
    connect: List['MessageWhereUniqueInput']
    connect_or_create: List['MessageConnectOrCreateWithoutRelationsInput']
    set: List['MessageWhereUniqueInput']
    disconnect: List['MessageWhereUniqueInput']
    delete: List['MessageWhereUniqueInput']

    # TODO
    # update: List['MessageUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MessageUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MessageScalarWhereInput']
    # upsert: List['MessageUpserteWithWhereUniqueWithoutRelationsInput']


class MessageUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MessageUpdateInput'
    # upsert: 'MessageUpsertWithoutRelationsInput'


class MessageUpsertInput(TypedDict):
    create: 'MessageCreateInput'
    update: 'MessageUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Message_id_OrderByInput = TypedDict(
    '_Message_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Message_sessionId_OrderByInput = TypedDict(
    '_Message_sessionId_OrderByInput',
    {
        'sessionId': 'SortOrder',
    },
    total=True
)

_Message_role_OrderByInput = TypedDict(
    '_Message_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_Message_content_OrderByInput = TypedDict(
    '_Message_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_Message_createdAt_OrderByInput = TypedDict(
    '_Message_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Message_RelevanceInner = TypedDict(
    '_Message_RelevanceInner',
    {
        'fields': 'List[MessageScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Message_RelevanceOrderByInput = TypedDict(
    '_Message_RelevanceOrderByInput',
    {
        '_relevance': '_Message_RelevanceInner',
    },
    total=True
)

MessageOrderByInput = Union[
    '_Message_id_OrderByInput',
    '_Message_sessionId_OrderByInput',
    '_Message_role_OrderByInput',
    '_Message_content_OrderByInput',
    '_Message_createdAt_OrderByInput',
    '_Message_RelevanceOrderByInput',
]



# recursive Message types
# TODO: cleanup these types



MessageRelationFilter = TypedDict(
    'MessageRelationFilter',
    {
        'is': 'MessageWhereInput',
        'is_not': 'MessageWhereInput',
    },
    total=False,
)


class MessageListRelationFilter(TypedDict, total=False):
    some: 'MessageWhereInput'
    none: 'MessageWhereInput'
    every: 'MessageWhereInput'


class MessageInclude(TypedDict, total=False):
    """Message relational arguments"""
    session: Union[bool, 'DebateSessionArgsFromMessage']


class UserIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromMessage']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromMessage']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromMessage']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromMessage']
    companionData: Union[bool, 'FindManycompanion_createArgsFromMessage']


class UserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""


class quizzesArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']


class quiz_resultArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']


class user_progressArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']


class bookmark_quizArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']
    messages: Union[bool, 'FindManyMessageArgsFromMessage']


class DebateSessionArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    session: Union[bool, 'DebateSessionArgsFromMessage']


class MessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    interactions: Union[bool, 'FindManyInteractionArgsFromMessage']
    user: Union[bool, 'UserArgsFromMessage']


class companion_createArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    companion: Union[bool, 'companion_createArgsFromMessage']


class InteractionArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyMessageArgs = FindManyMessageArgsFromMessage
FindFirstMessageArgs = FindManyMessageArgsFromMessage


class MessageWhereInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    session: 'DebateSessionRelationFilter'
    sessionId: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['MessageWhereInput', List['MessageWhereInput']]
    # but this causes mypy to hang :/
    AND: List['MessageWhereInput']
    OR: List['MessageWhereInput']
    NOT: List['MessageWhereInput']



# aggregate Message types


class MessageScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    sessionId: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MessageScalarWhereWithAggregatesInput']
    OR: List['MessageScalarWhereWithAggregatesInput']
    NOT: List['MessageScalarWhereWithAggregatesInput']



class MessageGroupByOutput(TypedDict, total=False):
    id: _str
    sessionId: _str
    role: _str
    content: _str
    createdAt: datetime.datetime
    _sum: 'MessageSumAggregateOutput'
    _avg: 'MessageAvgAggregateOutput'
    _min: 'MessageMinAggregateOutput'
    _max: 'MessageMaxAggregateOutput'
    _count: 'MessageCountAggregateOutput'


class MessageAvgAggregateOutput(TypedDict, total=False):
    """Message output for aggregating averages"""


class MessageSumAggregateOutput(TypedDict, total=False):
    """Message output for aggregating sums"""


class MessageScalarAggregateOutput(TypedDict, total=False):
    """Message output including scalar fields"""
    id: _str
    sessionId: _str
    role: _str
    content: _str
    createdAt: datetime.datetime


MessageMinAggregateOutput = MessageScalarAggregateOutput
MessageMaxAggregateOutput = MessageScalarAggregateOutput


class MessageMaxAggregateInput(TypedDict, total=False):
    """Message input for aggregating by max"""
    id: bool
    sessionId: bool
    role: bool
    content: bool
    createdAt: bool


class MessageMinAggregateInput(TypedDict, total=False):
    """Message input for aggregating by min"""
    id: bool
    sessionId: bool
    role: bool
    content: bool
    createdAt: bool


class MessageNumberAggregateInput(TypedDict, total=False):
    """Message input for aggregating numbers"""


MessageAvgAggregateInput = MessageNumberAggregateInput
MessageSumAggregateInput = MessageNumberAggregateInput


MessageCountAggregateInput = TypedDict(
    'MessageCountAggregateInput',
    {
        'id': bool,
        'sessionId': bool,
        'role': bool,
        'content': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

MessageCountAggregateOutput = TypedDict(
    'MessageCountAggregateOutput',
    {
        'id': int,
        'sessionId': int,
        'role': int,
        'content': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


MessageKeys = Literal[
    'id',
    'session',
    'sessionId',
    'role',
    'content',
    'createdAt',
]
MessageScalarFieldKeys = Literal[
    'id',
    'sessionId',
    'role',
    'content',
    'createdAt',
]
MessageScalarFieldKeysT = TypeVar('MessageScalarFieldKeysT', bound=MessageScalarFieldKeys)

MessageRelationalFieldKeys = Literal[
        'session',
    ]

# companion_create types

class companion_createOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the companion_create create method"""
    id: _str
    userId: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime
    interactions: 'InteractionCreateManyNestedWithoutRelationsInput'
    user: 'UserCreateNestedWithoutRelationsInput'


class companion_createCreateInput(companion_createOptionalCreateInput):
    """Required arguments to the companion_create create method"""
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class companion_createOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the companion_create create method, without relations"""
    id: _str
    userId: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime


class companion_createCreateWithoutRelationsInput(companion_createOptionalCreateWithoutRelationsInput):
    """Required arguments to the companion_create create method, without relations"""
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str

class companion_createConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'companion_createCreateWithoutRelationsInput'
    where: 'companion_createWhereUniqueInput'

class companion_createCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'companion_createCreateWithoutRelationsInput'
    connect: 'companion_createWhereUniqueInput'
    connect_or_create: 'companion_createConnectOrCreateWithoutRelationsInput'


class companion_createCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['companion_createCreateWithoutRelationsInput', List['companion_createCreateWithoutRelationsInput']]
    connect: Union['companion_createWhereUniqueInput', List['companion_createWhereUniqueInput']]
    connect_or_create: Union['companion_createConnectOrCreateWithoutRelationsInput', List['companion_createConnectOrCreateWithoutRelationsInput']]

_companion_createWhereUnique_id_Input = TypedDict(
    '_companion_createWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

companion_createWhereUniqueInput = _companion_createWhereUnique_id_Input


class companion_createUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime
    interactions: 'InteractionUpdateManyWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'


class companion_createUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime


class companion_createUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['companion_createCreateWithoutRelationsInput']
    connect: List['companion_createWhereUniqueInput']
    connect_or_create: List['companion_createConnectOrCreateWithoutRelationsInput']
    set: List['companion_createWhereUniqueInput']
    disconnect: List['companion_createWhereUniqueInput']
    delete: List['companion_createWhereUniqueInput']

    # TODO
    # update: List['companion_createUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['companion_createUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['companion_createScalarWhereInput']
    # upsert: List['companion_createUpserteWithWhereUniqueWithoutRelationsInput']


class companion_createUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'companion_createCreateWithoutRelationsInput'
    connect: 'companion_createWhereUniqueInput'
    connect_or_create: 'companion_createConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'companion_createUpdateInput'
    # upsert: 'companion_createUpsertWithoutRelationsInput'


class companion_createUpsertInput(TypedDict):
    create: 'companion_createCreateInput'
    update: 'companion_createUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_companion_create_id_OrderByInput = TypedDict(
    '_companion_create_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_companion_create_userId_OrderByInput = TypedDict(
    '_companion_create_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_companion_create_topic_OrderByInput = TypedDict(
    '_companion_create_topic_OrderByInput',
    {
        'topic': 'SortOrder',
    },
    total=True
)

_companion_create_level_OrderByInput = TypedDict(
    '_companion_create_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_companion_create_duration_OrderByInput = TypedDict(
    '_companion_create_duration_OrderByInput',
    {
        'duration': 'SortOrder',
    },
    total=True
)

_companion_create_voice_OrderByInput = TypedDict(
    '_companion_create_voice_OrderByInput',
    {
        'voice': 'SortOrder',
    },
    total=True
)

_companion_create_tone_OrderByInput = TypedDict(
    '_companion_create_tone_OrderByInput',
    {
        'tone': 'SortOrder',
    },
    total=True
)

_companion_create_timestamp_OrderByInput = TypedDict(
    '_companion_create_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_companion_create_created_at_OrderByInput = TypedDict(
    '_companion_create_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_companion_create_RelevanceInner = TypedDict(
    '_companion_create_RelevanceInner',
    {
        'fields': 'List[companion_createScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_companion_create_RelevanceOrderByInput = TypedDict(
    '_companion_create_RelevanceOrderByInput',
    {
        '_relevance': '_companion_create_RelevanceInner',
    },
    total=True
)

companion_createOrderByInput = Union[
    '_companion_create_id_OrderByInput',
    '_companion_create_userId_OrderByInput',
    '_companion_create_topic_OrderByInput',
    '_companion_create_level_OrderByInput',
    '_companion_create_duration_OrderByInput',
    '_companion_create_voice_OrderByInput',
    '_companion_create_tone_OrderByInput',
    '_companion_create_timestamp_OrderByInput',
    '_companion_create_created_at_OrderByInput',
    '_companion_create_RelevanceOrderByInput',
]



# recursive companion_create types
# TODO: cleanup these types



companion_createRelationFilter = TypedDict(
    'companion_createRelationFilter',
    {
        'is': 'companion_createWhereInput',
        'is_not': 'companion_createWhereInput',
    },
    total=False,
)


class companion_createListRelationFilter(TypedDict, total=False):
    some: 'companion_createWhereInput'
    none: 'companion_createWhereInput'
    every: 'companion_createWhereInput'


class companion_createInclude(TypedDict, total=False):
    """companion_create relational arguments"""
    interactions: Union[bool, 'FindManyInteractionArgsFromcompanion_create']
    user: Union[bool, 'UserArgsFromcompanion_create']


class UserIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromcompanion_create']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromcompanion_create']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromcompanion_create']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromcompanion_create']
    companionData: Union[bool, 'FindManycompanion_createArgsFromcompanion_create']


class UserArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""


class quizzesArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    user: Union[bool, 'UserArgsFromcompanion_create']


class quiz_resultArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    user: Union[bool, 'UserArgsFromcompanion_create']


class user_progressArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    user: Union[bool, 'UserArgsFromcompanion_create']


class bookmark_quizArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    user: Union[bool, 'UserArgsFromcompanion_create']
    messages: Union[bool, 'FindManyMessageArgsFromcompanion_create']


class DebateSessionArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    session: Union[bool, 'DebateSessionArgsFromcompanion_create']


class MessageArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    interactions: Union[bool, 'FindManyInteractionArgsFromcompanion_create']
    user: Union[bool, 'UserArgsFromcompanion_create']


class companion_createArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromcompanion_create(TypedDict, total=False):
    """Relational arguments for companion_create"""
    companion: Union[bool, 'companion_createArgsFromcompanion_create']


class InteractionArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromcompanion_create(TypedDict, total=False):
    """Arguments for companion_create"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManycompanion_createArgs = FindManycompanion_createArgsFromcompanion_create
FindFirstcompanion_createArgs = FindManycompanion_createArgsFromcompanion_create


class companion_createWhereInput(TypedDict, total=False):
    """companion_create arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    voice: Union[_str, 'types.StringFilter']
    tone: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    interactions: 'InteractionListRelationFilter'
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['companion_createWhereInput', List['companion_createWhereInput']]
    # but this causes mypy to hang :/
    AND: List['companion_createWhereInput']
    OR: List['companion_createWhereInput']
    NOT: List['companion_createWhereInput']



# aggregate companion_create types


class companion_createScalarWhereWithAggregatesInput(TypedDict, total=False):
    """companion_create arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    voice: Union[_str, 'types.StringWithAggregatesFilter']
    tone: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['companion_createScalarWhereWithAggregatesInput']
    OR: List['companion_createScalarWhereWithAggregatesInput']
    NOT: List['companion_createScalarWhereWithAggregatesInput']



class companion_createGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime
    _sum: 'companion_createSumAggregateOutput'
    _avg: 'companion_createAvgAggregateOutput'
    _min: 'companion_createMinAggregateOutput'
    _max: 'companion_createMaxAggregateOutput'
    _count: 'companion_createCountAggregateOutput'


class companion_createAvgAggregateOutput(TypedDict, total=False):
    """companion_create output for aggregating averages"""


class companion_createSumAggregateOutput(TypedDict, total=False):
    """companion_create output for aggregating sums"""


class companion_createScalarAggregateOutput(TypedDict, total=False):
    """companion_create output including scalar fields"""
    id: _str
    userId: _str
    topic: _str
    level: _str
    duration: _str
    voice: _str
    tone: _str
    timestamp: datetime.datetime
    created_at: datetime.datetime


companion_createMinAggregateOutput = companion_createScalarAggregateOutput
companion_createMaxAggregateOutput = companion_createScalarAggregateOutput


class companion_createMaxAggregateInput(TypedDict, total=False):
    """companion_create input for aggregating by max"""
    id: bool
    userId: bool
    topic: bool
    level: bool
    duration: bool
    voice: bool
    tone: bool
    timestamp: bool
    created_at: bool


class companion_createMinAggregateInput(TypedDict, total=False):
    """companion_create input for aggregating by min"""
    id: bool
    userId: bool
    topic: bool
    level: bool
    duration: bool
    voice: bool
    tone: bool
    timestamp: bool
    created_at: bool


class companion_createNumberAggregateInput(TypedDict, total=False):
    """companion_create input for aggregating numbers"""


companion_createAvgAggregateInput = companion_createNumberAggregateInput
companion_createSumAggregateInput = companion_createNumberAggregateInput


companion_createCountAggregateInput = TypedDict(
    'companion_createCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'topic': bool,
        'level': bool,
        'duration': bool,
        'voice': bool,
        'tone': bool,
        'timestamp': bool,
        'created_at': bool,
        '_all': bool,
    },
    total=False,
)

companion_createCountAggregateOutput = TypedDict(
    'companion_createCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'topic': int,
        'level': int,
        'duration': int,
        'voice': int,
        'tone': int,
        'timestamp': int,
        'created_at': int,
        '_all': int,
    },
    total=False,
)


companion_createKeys = Literal[
    'id',
    'userId',
    'topic',
    'level',
    'duration',
    'voice',
    'tone',
    'timestamp',
    'created_at',
    'interactions',
    'user',
]
companion_createScalarFieldKeys = Literal[
    'id',
    'userId',
    'topic',
    'level',
    'duration',
    'voice',
    'tone',
    'timestamp',
    'created_at',
]
companion_createScalarFieldKeysT = TypeVar('companion_createScalarFieldKeysT', bound=companion_createScalarFieldKeys)

companion_createRelationalFieldKeys = Literal[
        'interactions',
        'user',
    ]

# Interaction types

class InteractionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Interaction create method"""
    id: _str
    companionId: _str
    createdAt: datetime.datetime
    companion: 'companion_createCreateNestedWithoutRelationsInput'


class InteractionCreateInput(InteractionOptionalCreateInput):
    """Required arguments to the Interaction create method"""
    userInput: _str
    companionResponse: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class InteractionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Interaction create method, without relations"""
    id: _str
    companionId: _str
    createdAt: datetime.datetime


class InteractionCreateWithoutRelationsInput(InteractionOptionalCreateWithoutRelationsInput):
    """Required arguments to the Interaction create method, without relations"""
    userInput: _str
    companionResponse: _str

class InteractionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'InteractionCreateWithoutRelationsInput'
    where: 'InteractionWhereUniqueInput'

class InteractionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'InteractionCreateWithoutRelationsInput'
    connect: 'InteractionWhereUniqueInput'
    connect_or_create: 'InteractionConnectOrCreateWithoutRelationsInput'


class InteractionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['InteractionCreateWithoutRelationsInput', List['InteractionCreateWithoutRelationsInput']]
    connect: Union['InteractionWhereUniqueInput', List['InteractionWhereUniqueInput']]
    connect_or_create: Union['InteractionConnectOrCreateWithoutRelationsInput', List['InteractionConnectOrCreateWithoutRelationsInput']]

_InteractionWhereUnique_id_Input = TypedDict(
    '_InteractionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

InteractionWhereUniqueInput = _InteractionWhereUnique_id_Input


class InteractionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    userInput: _str
    companionResponse: _str
    createdAt: datetime.datetime
    companion: 'companion_createUpdateOneWithoutRelationsInput'


class InteractionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    userInput: _str
    companionResponse: _str
    createdAt: datetime.datetime


class InteractionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['InteractionCreateWithoutRelationsInput']
    connect: List['InteractionWhereUniqueInput']
    connect_or_create: List['InteractionConnectOrCreateWithoutRelationsInput']
    set: List['InteractionWhereUniqueInput']
    disconnect: List['InteractionWhereUniqueInput']
    delete: List['InteractionWhereUniqueInput']

    # TODO
    # update: List['InteractionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['InteractionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['InteractionScalarWhereInput']
    # upsert: List['InteractionUpserteWithWhereUniqueWithoutRelationsInput']


class InteractionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'InteractionCreateWithoutRelationsInput'
    connect: 'InteractionWhereUniqueInput'
    connect_or_create: 'InteractionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'InteractionUpdateInput'
    # upsert: 'InteractionUpsertWithoutRelationsInput'


class InteractionUpsertInput(TypedDict):
    create: 'InteractionCreateInput'
    update: 'InteractionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Interaction_id_OrderByInput = TypedDict(
    '_Interaction_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Interaction_companionId_OrderByInput = TypedDict(
    '_Interaction_companionId_OrderByInput',
    {
        'companionId': 'SortOrder',
    },
    total=True
)

_Interaction_userInput_OrderByInput = TypedDict(
    '_Interaction_userInput_OrderByInput',
    {
        'userInput': 'SortOrder',
    },
    total=True
)

_Interaction_companionResponse_OrderByInput = TypedDict(
    '_Interaction_companionResponse_OrderByInput',
    {
        'companionResponse': 'SortOrder',
    },
    total=True
)

_Interaction_createdAt_OrderByInput = TypedDict(
    '_Interaction_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Interaction_RelevanceInner = TypedDict(
    '_Interaction_RelevanceInner',
    {
        'fields': 'List[InteractionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Interaction_RelevanceOrderByInput = TypedDict(
    '_Interaction_RelevanceOrderByInput',
    {
        '_relevance': '_Interaction_RelevanceInner',
    },
    total=True
)

InteractionOrderByInput = Union[
    '_Interaction_id_OrderByInput',
    '_Interaction_companionId_OrderByInput',
    '_Interaction_userInput_OrderByInput',
    '_Interaction_companionResponse_OrderByInput',
    '_Interaction_createdAt_OrderByInput',
    '_Interaction_RelevanceOrderByInput',
]



# recursive Interaction types
# TODO: cleanup these types



InteractionRelationFilter = TypedDict(
    'InteractionRelationFilter',
    {
        'is': 'InteractionWhereInput',
        'is_not': 'InteractionWhereInput',
    },
    total=False,
)


class InteractionListRelationFilter(TypedDict, total=False):
    some: 'InteractionWhereInput'
    none: 'InteractionWhereInput'
    every: 'InteractionWhereInput'


class InteractionInclude(TypedDict, total=False):
    """Interaction relational arguments"""
    companion: Union[bool, 'companion_createArgsFromInteraction']


class UserIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    quiz_data_result: Union[bool, 'FindManyquiz_resultArgsFromInteraction']
    user_progress_report: Union[bool, 'FindManyuser_progressArgsFromInteraction']
    bookmark: Union[bool, 'FindManybookmark_quizArgsFromInteraction']
    debatePoint: Union[bool, 'FindManyDebateSessionArgsFromInteraction']
    companionData: Union[bool, 'FindManycompanion_createArgsFromInteraction']


class UserArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class quizzesIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""


class quizzesArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'quizzesIncludeFromquizzes'


class FindManyquizzesArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['quizzesOrderByInput', List['quizzesOrderByInput']]
    where: 'quizzesWhereInput'
    cursor: 'quizzesWhereUniqueInput'
    distinct: List['quizzesScalarFieldKeys']
    include: 'quizzesIncludeFromquizzes'


class quiz_resultIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    user: Union[bool, 'UserArgsFromInteraction']


class quiz_resultArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'quiz_resultIncludeFromquiz_result'


class FindManyquiz_resultArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['quiz_resultOrderByInput', List['quiz_resultOrderByInput']]
    where: 'quiz_resultWhereInput'
    cursor: 'quiz_resultWhereUniqueInput'
    distinct: List['quiz_resultScalarFieldKeys']
    include: 'quiz_resultIncludeFromquiz_result'


class user_progressIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    user: Union[bool, 'UserArgsFromInteraction']


class user_progressArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'user_progressIncludeFromuser_progress'


class FindManyuser_progressArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['user_progressOrderByInput', List['user_progressOrderByInput']]
    where: 'user_progressWhereInput'
    cursor: 'user_progressWhereUniqueInput'
    distinct: List['user_progressScalarFieldKeys']
    include: 'user_progressIncludeFromuser_progress'


class bookmark_quizIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    user: Union[bool, 'UserArgsFromInteraction']


class bookmark_quizArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class FindManybookmark_quizArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['bookmark_quizOrderByInput', List['bookmark_quizOrderByInput']]
    where: 'bookmark_quizWhereInput'
    cursor: 'bookmark_quizWhereUniqueInput'
    distinct: List['bookmark_quizScalarFieldKeys']
    include: 'bookmark_quizIncludeFrombookmark_quiz'


class DebateSessionIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    user: Union[bool, 'UserArgsFromInteraction']
    messages: Union[bool, 'FindManyMessageArgsFromInteraction']


class DebateSessionArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'DebateSessionIncludeFromDebateSession'


class FindManyDebateSessionArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['DebateSessionOrderByInput', List['DebateSessionOrderByInput']]
    where: 'DebateSessionWhereInput'
    cursor: 'DebateSessionWhereUniqueInput'
    distinct: List['DebateSessionScalarFieldKeys']
    include: 'DebateSessionIncludeFromDebateSession'


class MessageIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    session: Union[bool, 'DebateSessionArgsFromInteraction']


class MessageArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class companion_createIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    interactions: Union[bool, 'FindManyInteractionArgsFromInteraction']
    user: Union[bool, 'UserArgsFromInteraction']


class companion_createArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'companion_createIncludeFromcompanion_create'


class FindManycompanion_createArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['companion_createOrderByInput', List['companion_createOrderByInput']]
    where: 'companion_createWhereInput'
    cursor: 'companion_createWhereUniqueInput'
    distinct: List['companion_createScalarFieldKeys']
    include: 'companion_createIncludeFromcompanion_create'


class InteractionIncludeFromInteraction(TypedDict, total=False):
    """Relational arguments for Interaction"""
    companion: Union[bool, 'companion_createArgsFromInteraction']


class InteractionArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    include: 'InteractionIncludeFromInteraction'


class FindManyInteractionArgsFromInteraction(TypedDict, total=False):
    """Arguments for Interaction"""
    take: int
    skip: int
    order_by: Union['InteractionOrderByInput', List['InteractionOrderByInput']]
    where: 'InteractionWhereInput'
    cursor: 'InteractionWhereUniqueInput'
    distinct: List['InteractionScalarFieldKeys']
    include: 'InteractionIncludeFromInteraction'




FindManyInteractionArgs = FindManyInteractionArgsFromInteraction
FindFirstInteractionArgs = FindManyInteractionArgsFromInteraction


class InteractionWhereInput(TypedDict, total=False):
    """Interaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    companionId: Union[_str, 'types.StringFilter']
    userInput: Union[_str, 'types.StringFilter']
    companionResponse: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    companion: 'companion_createRelationFilter'

    # should be noted that AND and NOT should be Union['InteractionWhereInput', List['InteractionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['InteractionWhereInput']
    OR: List['InteractionWhereInput']
    NOT: List['InteractionWhereInput']



# aggregate Interaction types


class InteractionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Interaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    companionId: Union[_str, 'types.StringWithAggregatesFilter']
    userInput: Union[_str, 'types.StringWithAggregatesFilter']
    companionResponse: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['InteractionScalarWhereWithAggregatesInput']
    OR: List['InteractionScalarWhereWithAggregatesInput']
    NOT: List['InteractionScalarWhereWithAggregatesInput']



class InteractionGroupByOutput(TypedDict, total=False):
    id: _str
    companionId: _str
    userInput: _str
    companionResponse: _str
    createdAt: datetime.datetime
    _sum: 'InteractionSumAggregateOutput'
    _avg: 'InteractionAvgAggregateOutput'
    _min: 'InteractionMinAggregateOutput'
    _max: 'InteractionMaxAggregateOutput'
    _count: 'InteractionCountAggregateOutput'


class InteractionAvgAggregateOutput(TypedDict, total=False):
    """Interaction output for aggregating averages"""


class InteractionSumAggregateOutput(TypedDict, total=False):
    """Interaction output for aggregating sums"""


class InteractionScalarAggregateOutput(TypedDict, total=False):
    """Interaction output including scalar fields"""
    id: _str
    companionId: _str
    userInput: _str
    companionResponse: _str
    createdAt: datetime.datetime


InteractionMinAggregateOutput = InteractionScalarAggregateOutput
InteractionMaxAggregateOutput = InteractionScalarAggregateOutput


class InteractionMaxAggregateInput(TypedDict, total=False):
    """Interaction input for aggregating by max"""
    id: bool
    companionId: bool
    userInput: bool
    companionResponse: bool
    createdAt: bool


class InteractionMinAggregateInput(TypedDict, total=False):
    """Interaction input for aggregating by min"""
    id: bool
    companionId: bool
    userInput: bool
    companionResponse: bool
    createdAt: bool


class InteractionNumberAggregateInput(TypedDict, total=False):
    """Interaction input for aggregating numbers"""


InteractionAvgAggregateInput = InteractionNumberAggregateInput
InteractionSumAggregateInput = InteractionNumberAggregateInput


InteractionCountAggregateInput = TypedDict(
    'InteractionCountAggregateInput',
    {
        'id': bool,
        'companionId': bool,
        'userInput': bool,
        'companionResponse': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

InteractionCountAggregateOutput = TypedDict(
    'InteractionCountAggregateOutput',
    {
        'id': int,
        'companionId': int,
        'userInput': int,
        'companionResponse': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


InteractionKeys = Literal[
    'id',
    'companionId',
    'userInput',
    'companionResponse',
    'createdAt',
    'companion',
]
InteractionScalarFieldKeys = Literal[
    'id',
    'companionId',
    'userInput',
    'companionResponse',
    'createdAt',
]
InteractionScalarFieldKeysT = TypeVar('InteractionScalarFieldKeysT', bound=InteractionScalarFieldKeys)

InteractionRelationalFieldKeys = Literal[
        'companion',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields